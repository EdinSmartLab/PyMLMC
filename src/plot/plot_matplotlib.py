
# # # # # # # # # # # # # # # # # # # # # # # # # #
# Plotting routines for stats generated by PyMLMC
# TODO: add paper, description and link
#
# Jonas Sukys
# CSE Lab, ETH Zurich, Switzerland
# sukys.jonas@gmail.com
# All rights reserved.
# # # # # # # # # # # # # # # # # # # # # # # # # #

# === local imports

import local

# === global imports

import matplotlib

# for pylab.tight_layout()
matplotlib.use('agg')

import pylab
import numpy
import sys
import time

# warnings management
import warnings
warnings.filterwarnings ('ignore', message='No labelled objects found. ')   # when empty subplot is displayed due to failed runs

# figure configuration
if not local.cluster:
  matplotlib.rcParams ['figure.max_open_warning'] = 100
matplotlib.rcParams ['savefig.dpi']             = 300

# font configuration
matplotlib.rcParams ['font.size']             = 16
matplotlib.rcParams ['legend.fontsize']       = 14
matplotlib.rcParams ['lines.linewidth']       = 3
matplotlib.rcParams ['lines.markeredgewidth'] = 3
matplotlib.rcParams ['lines.markersize']      = 10

# additional colors
matplotlib.colors.ColorConverter.colors ['custom_blue']   = ( 38/256.0, 135/256.0, 203/256.0)
matplotlib.colors.ColorConverter.colors ['custom_orange'] = (251/256.0, 124/256.0,  42/256.0)
matplotlib.colors.ColorConverter.colors ['custom_green']  = (182/256.0, 212/256.0,  43/256.0)

# default color cycle (not working on MIRA)
matplotlib.rcParams ['axes.color_cycle'] = ['custom_blue', 'custom_orange', 'custom_green'] + list (matplotlib.colors.cnames.keys())

# === parser for base qoi

def base (qoi):
  
  if qoi in colors.keys() or qoi == None:
    return qoi
  elif len (qoi) > 3 and qoi [2] == '_' and qoi [:2] in colors.keys():
    return qoi [:2]
  elif len (qoi) > 2 and qoi [1] == '_' and qoi [0] in colors.keys():
    return qoi [0]
  else:
    return qoi

# === colors (specified by the stat, param or qoi)

# statistical estimators

colors_stats = {}

colors_stats ['default']          = 'custom_blue'

colors_stats ['mean']             = 'custom_blue'
colors_stats ['percentile']       = 'custom_orange'
colors_stats ['std. deviation']   = 'custom_green'

def color_stats (name):
  color = colors_stats [name] if name in colors_stats else colors_stats ['default']
  if 'percentile' in name: color = colors_stats ['percentile']
  return color

# MLMC parameters

colors_params = {}

colors_params ['default']     = 'custom_blue'

colors_params ['epsilon']     = 'custom_blue'
colors_params ['sigma']       = 'custom_orange'
colors_params ['samples']     = 'custom_green'
colors_params ['budget']      = 'olivedrab'
colors_params ['warmup']      = 'saddlebrown'
colors_params ['optimal']     = 'yellowgreen'
colors_params ['correlation'] = 'darkorchid'
colors_params ['coefficient'] = 'darkorchid'
colors_params ['errors']      = 'coral'
colors_params ['error']       = 'lightskyblue'
colors_params ['tol']         = 'darkorchid'

def color_params (name):
  color = colors_params [name] if name in colors_params else colors_params ['default']
  return color

# quantities of interest from simulation

colors = {}

colors ['default']   = 'custom_blue'
colors ['pos']       = 'darkslategrey'
colors ['trendline'] = 'darkorange'
colors ['t']         = 'grey'

colors ['a']   = 'custom_blue'
colors ['a2']  = 'custom_blue'
colors ['r']   = 'saddlebrown'
colors ['r2']  = 'burlywood'
colors ['u']   = 'red'
colors ['v']   = 'green'
colors ['w']   = 'blue'
colors ['m']   = 'darkgoldenrod'
colors ['ke']  = 'mediumseagreen'
colors ['e']   = 'cyan'
colors ['W']   = 'darkorchid'
colors ['p']   = 'orangered'
colors ['pw']  = 'custom_orange'
colors ['c']   = 'forestgreen'
colors ['M']   = 'darkturquoise'
colors ['V2']  = 'steelblue'
colors ['Req'] = 'steelblue'
colors ['Vc']  = 'custom_blue'

# other

colors ['rp_integrated']    = 'black'
colors ['rp_approximated']  = 'black'

def color (qoi):
  if '_pos' in qoi:
    return colors ['pos']
  if '_time' in qoi:
    return colors ['t']
  base_qoi = base (qoi)
  if base_qoi in colors.keys():
    return colors [base_qoi]
  else:
    return colors ['default']

# === styles (specified by the run)

styles = ['-', '--', ':', '-.']

def style (run):
  if (run - 1) < len (styles):
    return styles [run-1]
  else:
    return '-'

# === alphas (specified by the run)

alphas = [1.0, 0.6, 0.3, 0.1]

def alpha (run):
  if (run - 1) < len (alphas):
    return alphas [run-1]
  else:
    return '-'

# === units

units = {}

units ['t']    = r'$\mu s$'
units ['pos']  = r'$mm$'

units ['a']    = r'$-$'
units ['a2']   = r'$-$'
units ['r']    = r'$kg/m^3$'
units ['r2']   = r'$kg/m^3$'
units ['u']    = r'$mm/\mu s$'
units ['v']    = r'$mm/\mu s$'
units ['w']    = r'$mm/\mu s$'
units ['m']    = r'$mm/\mu s$'
units ['ke']   = r'$J$' # check
units ['W']    = r'$\mu s^{-1}$'
units ['e']    = r'$J$' # check
units ['p']    = r'$MPa$'
units ['pw']   = r'$MPa$'
units ['c']    = r'$mm/\mu s$'
units ['M']    = r'$-$'
units ['V2']   = r'$mm^3$'
units ['Req']  = r'$mm$'
units ['Vc']   = r'$mm^3$'

def unit (qoi):
  if '_pos' in qoi:
    return units ['pos']
  if '_shell' in qoi:
    return units ['pos']
  if '_time' in qoi:
    return units ['t']
  base_qoi = base (qoi)
  if base_qoi in units.keys():
    return units [base_qoi]
  else:
    return r'$???$'

# === names

names = {}

names ['t']   = 'time'
names ['a']   = 'vapor fraction'
names ['a2']  = 'vapor fraction'
names ['r']   = 'density'
names ['r2']  = 'gas density'
names ['u']   = 'x-velocity'
names ['v']   = 'y-velocity'
names ['w']   = 'z-velocity'
names ['m']   = 'velocity magnitude'
names ['ke']  = 'kinetic energy'
names ['W']   = 'vorticity magnitude'
names ['e']   = 'total energy'
names ['p']   = 'pressure'
names ['pw']  = 'wall pressure'
names ['c']   = 'speed of sound'
names ['M']   = 'Mach number'
names ['V2']  = 'gas volume'
names ['Req'] = 'equivalent radius'
names ['Vc']  = 'cloud volume'

def name (qoi, short=False):
  
  base_qoi = base (qoi)
  
  if not short and base_qoi in names.keys():
    name_ = names [base_qoi]
  else:
    name_ = base_qoi

  if '_avg' in qoi:
    name_ = 'avg ' + name_
  if '_min' in qoi:
    name_ = 'min ' + name_
  if '_max' in qoi:
    name_ = 'max ' + name_

  if '_sensor' in qoi:
    id = qoi.split ('_sensor', 1) [1]
    name_ = name_ + ' sensor ' + id
  if '_shell' in qoi:
    name_ = 'shell ' + name_
    id = qoi.split ('_shell_avg', 1) [1]
    if id != '':
      name_ += ' ' + id
  if '_time' in qoi:
    name_ = 'time of ' + name_

  if short and '_pos' in qoi:
    name_ = name_ + ' pos'
  else:
    if '_pos_x' in qoi:
      name_ = 'x-pos. of ' + name_
    if '_pos_y' in qoi:
      name_ = 'y-pos. of ' + name_
    if '_pos_z' in qoi:
      name_ = 'z-pos. of ' + name_
    if '_pos_d' in qoi:
      if not '_pos_d_x' in qoi and not '_pos_d_y' in qoi and not '_pos_d_z' in qoi:
        name_ = 'dist. of ' + name_
    if '_pos_d_x' in qoi:
      name_ = 'x-dist. of ' + name_
    if '_pos_d_y' in qoi:
      name_ = 'y-dist. of ' + name_
    if '_pos_d_z' in qoi:
      name_ = 'z-dist. of ' + name_
  
  return name_

# === helper routines

# create a new solid color which is slighly brighter
def brighten (color, factor=0.7):
  rgb = list (matplotlib.colors.ColorConverter().to_rgb (color))
  brighter = rgb
  for channel, value in enumerate (rgb):
    brighter [channel] += factor * (1.0 - value)
  return tuple (brighter)

# set levels extent
def levels_extent (levels):
  pylab.xlim ( [ -0.2 + levels [0], levels [-1] + 0.2 ] )
  pylab.xticks (levels)

def adjust_extent (data, factor=1.5, offset=0):
  pylab.gca().set_ylim (top    = numpy.max (data) * factor + offset)
  pylab.gca().set_ylim (bottom = numpy.min (data) / factor - offset)

# generate figure name using the format 'figpath/pwd_suffix.extension'
def figname (figpath='fig', dataclass='unknown', suffix='', extension='pdf'):
  import os
  if not os.path.exists (figpath):
    os.mkdir (figpath)
  runpath, rundir = os.path.split (os.getcwd())
  if suffix == '':
    return os.path.join (figpath, rundir + '_' + dataclass + '_' + '.' + extension)
  else:
    return os.path.join (figpath, rundir + '_' + dataclass + '_' + suffix + '.' + extension)

# filter
def filter (vs, width):
  if width % 2 != 0:
    width += 1
  vs_ext = numpy.r_ [ vs [width-1:0:-1], vs, vs [-1:-width:-1] ]
  window = numpy.hanning (width)
  window /= window.sum()
  vs_cnv = numpy.convolve (window, vs_ext, mode='valid')
  return vs_cnv [width / 2 - 1 : len (vs_cnv) - width / 2]

# execute command in terminal
def execute (cmd, directory='.', verbose=1, pipe=0):
  
  import os, subprocess

  if verbose:
    print
    print cmd
    print
  
  if pipe:
    stdout = subprocess.PIPE
  else:
    stdout = subprocess.STDOUT
  
  # execute command
  if pipe:
    proc = subprocess.Popen ( cmd, cwd=directory, stdout=subprocess.PIPE, shell=True, env=os.environ.copy() )
  else:
    subprocess.check_call ( cmd, cwd=directory, shell=True, env=os.environ.copy() )
  
  # return output
  if pipe:
    (out, err) = proc.communicate()
    return out

# main class for plotting using MatPlotLib
class MatPlotLib (object):

  extent  = None
  surface = None

  xend_max = None

  # initialization
  def __init__ (self, mlmc, autosave=0, auto=False, figpath='fig', movpath='mov', timeformat='%.2f'):

    self.mlmc       = mlmc
    self.autosave   = autosave
    self.auto       = auto
    self.figpath    = figpath
    self.movpath    = movpath
    self.timeformat = timeformat
    self.dimensions = mlmc.config.solver.dataclass.dimensions

    if mlmc.config.solver.dataclass.dimensions >= 3:
      self.mlmc.helpers.warning ('Only 1-D and 2-D statistics plotting are available')

    # non-blocking pylab.show ()
    if self.auto:
      pylab.ion ()

    print
    print ' :: MatPlotLib plotting backend initialized.'

  # === LaTeX generation tools

  # compute parameters needed for the generation of the TexTable
  def getTexTableConfig (self):
    
    # config
    
    keys     =  ['grid_size', 'cores', 'runtime', 'cluster']
    captions =  ['grid size', 'cores', 'runtime', 'cluster']
    
    # aggregation of information
    
    import time
    
    values               = {}
    values ['grid_size'] = 'x'.join ( [ str(parameter) for parameter in self.mlmc.config.discretizations [self.mlmc.config.L] .values() ] )
    values ['cores']     = self.mlmc.status.list ['parallelization']
    values ['cluster']   = self.mlmc.status.list ['cluster']
    
    if self.mlmc.finished:
      runtime = self.mlmc.mcs [self.mlmc.config.L] .timer (batch=1) ['max']
      values ['runtime'] = time.strftime ( '%H:%M:%S', time.gmtime (runtime) )
    else:
      values ['runtime'] = self.mlmc.status.list ['walltimes'] [-1] [0]
    
    # number of levels

    if self.mlmc.config.L != 0:
      keys = ['L'] + keys
      captions = [r'$L$'] + captions
      values ['L'] = self.mlmc.config.L
    
    return [keys, captions, values]

  # generate TeX code with the table including information about the simulation
  def generateTexTable (self, base):
    
    # get the config
    
    [keys, captions, opts] = self.getTexTableConfig ()
    
    # TeX code generation
    
    columns =  '|' + 'c|' * len(keys)
    
    text =  '\n'
    text += r'\begin{tabular}{%s}' % columns + '\n'
    
    text += r'\hline' + '\n'
    text += (r'%s & ' * len(captions))[0:-2] % tuple(captions) + r'\\' + '\n'
    text += r'\hline' + '\n'
    text += (r'%s & ' * len(keys))[0:-2] % tuple([opts[key] for key in keys]) + r'\\' + '\n'
    text += r'\hline' + '\n'
    
    text += r'\end{tabular}' + '\n'
    
    # saving
    f = open (base + '.tex', 'w')
    f.write (text)
    f.close ()

  # === plotting helpers

  def figure (self, infolines=False, line=None, subplots=1):

    if infolines:
      if self.dimensions == 1 or (self.dimensions == 2 and line != None):
        pylab.figure (figsize=(subplots*8,6))
      else:
        pylab.figure (figsize=(subplots*8,8))
    else:
      if self.dimensions == 1 or (self.dimensions == 2 and line != None):
        pylab.figure (figsize=(subplots*8,5))
      else:
        pylab.figure (figsize=(subplots*8,7))

  # plot infolines with information about the simulation
  def infolines (self):
    
    '''
    # text formatter
    def format_text (text, subplots):
      if not subplots and len(text) > 65:
        cut_pos = len(text)/2
        cut_pos = text.find(' ', cut_pos)
        text = text[:cut_pos] + '\n' + ' ' * 9 + text[cut_pos:]
      return text
    
    # CONF
    text  = prefix + format_text('CONF:' + ???, subplots) + '\n'
    
    # OPTS
    text += prefix + format_text('OPTS: ' + self.mlmc.options, subplots) + '\n'
    
    # INFO
    [keys, captions, values] = getTexTableConfig (mlmc)
    
    string_info  = ' CLUSTER: ' + config ['cluster']
    string_info += ', cores: ' + str(helpers.intf(int(config ['cores'])))
    string_info += ', runtime: ' + config ['runtime']

    text += prefix + format_text('INFO:' + string_info, subplots)
    
    # SAMPLES
    samples_available = self.samples and (self.i.L != 0 or self.i.ML != 1 or self.i.READ_NUMBER_OF_SAMPLES_FROM_FILE)
    if samples_available:
      text += '\n' + prefix + 'SAMPLES: ' + str(self.samples[::-1])[1:-1]
    
    # MESH_LEVEL and TYPE
    if level != None:
      text += ' (only the %d-sample MC estimate from MESH_LEVEL=%d and TYPE=%d is displayed)' % (self.samples[level+type], level, type)
    
    # default parallelization
    if self.default_parallelization:
      if samples_available:
        text += ' | '
      else:
        text += '\n'
      text += 'PARALLELIZATION:'
      for level in range(len(self.default_parallelization)):
        text += ' ' + str(self.default_parallelization[level][3]) + 'x(' + str(self.default_parallelization[level][0])
        if self.i.NY > 1: text += 'x' + str(self.default_parallelization[level][1])
        if self.i.NZ > 1: text += 'x' + str(self.default_parallelization[level][2])
        text += ')'
    
    return text
    '''
    return None

  def saveall (self, save, qoi=None, formats=['eps','png','pdf']):
    base_name = save [:-4]
    if qoi != None:
      base_name += '_' + qoi
    if formats == None:
      pylab.savefig (base_name + save [-4:])
    else:
      for format in formats:
        pylab.savefig (base_name + '.' + format)
      self.generateTexTable (base_name)

  def draw (self, save, qoi=None, legend=False, loc='best', suffix='autosave', formats=['eps','png','pdf']):
    
    # reset xend_max
    self.xend_max = None
    
    if legend or (qoi != None and '_pos' in qoi):
      pylab.legend (loc = loc)

    if save:
      self.saveall (save, qoi, formats)
    elif self.autosave:
      self.saveall (figname (self.figpath, self.mlmc.config.solver.dataclass.name, suffix), qoi, formats)
    pylab.draw ()

  # show plots
  def show (self):

    # report success
    print
    print ' :: Done! Go watch some nice (hopefully) pictures :)'

    # show all figures
    pylab.show ()

    # query for action
    if self.auto:
      self.query ()
  
  # close all figures
  def close (self, target='all'):
    
    pylab.close (target)
    pylab.close ()

  # query for action
  def query (self):

    print
    raw_input ('Press ENTER to continue... ')
    pylab.close ('all')

  # center extent
  def center_extent (self, qoi, extent):

    if extent and extent [0] != None and extent [1] != None:
      extent_range    = extent [1] - extent [0]
      extent_centered = ( - 0.5 * extent_range, 0.5 * extent_range )
    elif '_pos_d' in qoi:
      extent_centered = ( - 1.05 * self.surface, 1.05 * self.surface )
    else:
      extent_centered = None

    '''
    if 'shell' in qoi and extent_centered != None:
      extent_centered = [ 2 * extent_centered [0], 2 * extent_centered [1] ]
    '''

    return extent_centered

  # === plotting routines

  # plot a line indicating position
  def helper_lines (self, qoi, run=1, size=1):
    
    if self.dimensions == 1 and size <= 2:
      pylab.axhline (y=0, color='black', linestyle='-', linewidth=2, alpha=0.3)
    
    if '_pos_d' in qoi or 'shell' in qoi:

      if self.surface != None:
        pylab.axhline (y=self.surface,  color='maroon', linestyle='--', alpha=alpha(run), label='cloud surface')
        pylab.axhline (y=-self.surface, color='maroon', linestyle='--', alpha=alpha(run))
  
  # adjust subplot margins
  def adjust (self, infolines, line=None, subplots=1, sup=False):

    #if line != None:
    #  self.mlmc.config.solver.dataclass.name = 'line'
    
    if self.dimensions == 1 or (self.dimensions == 2 and line != None):

      if sup:
        pylab.subplots_adjust (top=0.86)
      else:
        pylab.subplots_adjust (top=0.90)

      if infolines:
        pylab.subplots_adjust (bottom=0.28)
      else:
        pylab.subplots_adjust (bottom=0.15)

      left = max (0.03, 0.16/subplots)
      pylab.subplots_adjust (left=left)

      right = min ( 0.98, 0.94 + 0.01 * subplots)
      pylab.subplots_adjust (right=right)

    elif self.dimensions == 2:

      pylab.subplots_adjust (top=0.88)

      if infolines:
        pylab.subplots_adjust (bottom=0.20)
      else:
        pylab.subplots_adjust (bottom=0.10)

      left = max (0.03, 0.10/subplots)
      pylab.subplots_adjust (left=left)

      pylab.subplots_adjust (right=0.98)

  # adjust axes
  def adjust_axes (self, qoi, extent, xorigin, yorigin, line, xend=None, yend=None):

    if self.dimensions > 1 and line == None:
      return

    # fit all existing data first
    pylab.gca().axis ('auto')
    
    # adjust x-axis
    if xorigin:
      pylab.gca().set_xlim (left = 0)

    if xend != None:
      if self.xend_max == None:
        self.xend_max = xend
      else:
        self.xend_max = max (xend, self.xend_max)
      pylab.gca().set_xlim (right = self.xend_max)

    # if extent is specified, use that
    if extent:
      pylab.ylim (*extent)

    # otherwise perform some automatic axes modifications based on parameters
    else:
      
      if yorigin:
        pylab.gca().set_ylim (bottom = 0)
      
      if yend:
        pylab.gca().set_ylim (top = yend)
      
      if qoi == None:
        return
    
      # this should be perfomed _only_ if data is too close
      #pylab.gca().set_ylim (top = 1.05 * pylab.ylim() [1])
      
      ylim = pylab.ylim() [1]

      if '_pos_d' in qoi and self.surface != None:
        pylab.gca().set_ylim (top = 1.05 * self.surface)
        #pylab.gca().set_ylim (top = max (1.05 * self.surface, ylim))

      if '_pos_x' in qoi and self.extent != None:
        pylab.gca().set_ylim (top = max (self.extent, ylim))
      if '_pos_y' in qoi and self.extent != None:
        pylab.gca().set_ylim (top = max (self.extent, ylim))
      if '_pos_z' in qoi and self.extent != None:
        pylab.gca().set_ylim (top = max (self.extent, ylim))

  # plot histogram
  def histogram (self, qoi, stat, extent, centered, line=None, log=1):

    # for debugging only
    log = 1

    vs = stat.estimate.data [qoi]

    if stat.estimate.dimensions == 2 and line != None:
      index = int ( line * stat.estimate.meta ['NY'] )
      vs = vs [:, index, :]

    # upscale time dimension
    samples = 200
    steps   = len (stat.estimate.meta ['x'])
    if steps > samples:
      from math import ceil
      stride = int ( ceil ( steps / samples ) ) 
      if steps % stride != 0:
        padding = stride - steps % stride
        nans    = numpy.empty ((padding, vs.shape[1]))
        nans.fill (float('nan'))
        padded  = numpy.vstack ( [ vs, nans ] )
      else:
        padded = vs
      shape = padded.T.shape
      downsampled = numpy.nanmean ( padded.T.reshape ((padded.T.shape [0], padded.T.shape [1] / stride, stride)), axis=2 ).T
    else:
      downsampled = vs

    extent = ( stat.estimate.meta ['x'] [0], stat.estimate.meta ['x'] [-1], extent [0], extent [1] )

    if centered:
      vmax =   1.0
      vmin = - 1.0
      cmap = 'seismic'
    else:
      vmax = 1.0
      vmin = 0.0
      colors = [ brighten ( color (qoi), factor=1.0 ), color (qoi) ]
      cmap = matplotlib.colors.LinearSegmentedColormap.from_list ( 'gradient', colors )

    masked = numpy.where ( downsampled == 0.0, 1e-16, downsampled )

    if log and not centered:
      from matplotlib.colors import LogNorm
      norm = LogNorm (vmin=0, vmax=vmax)
      vmin = 1e-3
    else:
      norm = None

    #interpolation = 'none'
    interpolation = 'hermite'

    pylab.imshow (numpy.transpose (masked), cmap=cmap, origin='lower', aspect='auto', norm=norm, extent=extent, interpolation=interpolation, vmin=vmin, vmax=vmax)
    colorbar = pylab.colorbar ()
    colorbar.set_label ('probability')

  # plot each stat
  def stats (self, qoi, stats, extent, xorigin, yorigin, log, run=1, line=None, legend=True, centered=False):

    # reversed plotting of stats (to avoid stats hindering each other)
    for stat in reversed (stats):

      # centered data - center extent as well
      if centered and stat.size <= 2:
        stat_extent = self.center_extent (qoi, extent)
      else:
        stat_extent = extent

      # if the specified qoi was not assembled, continue
      if not stat.available or qoi not in stat.estimate.data:
        continue
      
      # 1-D statistics
      if stat.estimate.dimensions == 1 or (stat.estimate.dimensions == 2 and line != None):

        # load data
        ts = numpy.array ( stat.estimate.meta ['x'] )
        vs = numpy.array ( stat.estimate.data [qoi] )

        # special plotting for multi-dimensional statistics (e.g. histograms, correlations)
        if stat.size > 2:
          if stat.name == 'histogram':
            if stat_extent != None:
              self.histogram (qoi, stat, stat_extent, centered, line, log)
            else:
              #self.mlmc.helpers.warning ('Histogram plotting requires explicit specification of \'extent\'')
              continue
          else:
            self.mlmc.helpers.warning ('Statistics with size larger than 2 are not supported [exception: histogram]')
            continue

        # extract line data
        if self.dimensions == 2 and line != None:
          index = int ( line * stat.estimate.meta ['NY'] )
          vs = vs [:, index]
          ts = stat.estimate.meta ['x']
        
        # plot size 2 statistics (e.g. confidence intervals)
        if stat.size == 2:
          lower  = vs [:, 0]
          upper  = vs [:, 1]
          factor = 0.8 * stat.alpha
          bright = brighten (color(qoi), factor=factor)
          pylab.fill_between (ts, lower, upper, facecolor=bright, edgecolor=bright, linewidth=3)
          # hack to show the legend entry
          pylab.plot ([], [], color=bright, linewidth=10, label=stat.name)
          continue
          
        # general plotting for size 1 statistics (e.g. mean, median, variance)
        if stat.size == 1:
          pylab.plot (ts, vs, color=color(qoi), linestyle=style(run), alpha=alpha(run), label=stat.name)

        if log and not centered:
          pylab.gca().set_yscale ('log', nonposy='clip')

        pylab.xlabel ('%s [%s]' % (stat.estimate.meta ['xlabel'], stat.estimate.meta ['xunit']))
        pylab.ylabel ('%s [%s]' % (name (qoi), unit (qoi)))
      
      # 2-D statistics
      elif stat.estimate.dimensions == 2:

        # only size 1 statistic can be plotted as an image
        if stat.size != 1:
          self.mlmc.helpers.warning ('For 2-D data class, only scalar valued statistics can be plotted')
          continue

        if stat.estimate.name == 'shells':
          aspect = 'auto'
        else:
          aspect = 'equal'

        # load data
        vs = numpy.array ( stat.estimate.data [qoi] )

        data_extent = ( stat.estimate.meta ['xrange'] [0], stat.estimate.meta ['xrange'] [1], stat.estimate.meta ['yrange'] [0], stat.estimate.meta ['yrange'] [1] )

        vmax = stat_extent [1] if extent != None else None
        vmin = stat_extent [0] if extent != None else None
        if log and not centered:
          from matplotlib.colors import LogNorm
          norm = LogNorm (vmin=0, vmax=vmax)
        else:
          norm = None

        if centered:
          cmap = 'seismic'
        else:
          cmap = matplotlib.colors.LinearSegmentedColormap.from_list ( 'gradient', ['white', color (qoi)] )

        pylab.imshow (numpy.transpose (vs), cmap=cmap, origin='lower', aspect=aspect, norm=norm, extent=data_extent, interpolation='hermite', vmin=vmin, vmax=vmax)
        pylab.colorbar ()

        pylab.xlabel ('%s [%s]' % (stat.estimate.meta ['xlabel'], stat.estimate.meta ['xunit']))
        pylab.ylabel ('%s [%s]' % (stat.estimate.meta ['ylabel'], stat.estimate.meta ['yunit']))

      # high dimensional statistics
      elif stat.estimate.dimensions >= 3:

        self.mlmc.helpers.warning ('Only 1-D and 2-D statistics plotting are available')
        continue

    '''
    # return if no statistic was plotted
    if sum ( [ stat.available and qoi in stat.estimate.data for stat in stats ] ) == 0:
      return
    '''

    self.helper_lines (qoi, run, size=stat.size)

    self.adjust_axes (qoi, stat_extent, xorigin, yorigin, line)
    
    if legend:
      # plot legend with reversed ordering
      handles, labels = pylab.gca().get_legend_handles_labels ()
      if handles != [] and labels != []:
        pylab.legend (handles[::-1], labels[::-1], loc='best')

  # set title according to different parameters
  def title (self, stage, qoi, title, sup=False):

    if not title: return

    if (self.dimensions == 2 or (self.dimensions == 1 and self.mlmc.stats [0] .size > 2)) and len (self.mlmc.stats) == 1:
      statname = self.mlmc.stats [0] .name
    else:
      statname = 'statistics'

    text = '%s %s for %s %s' % (stage, statname, name (qoi), self.mlmc.config.solver.dataclass.name)

    if sup:
      pylab.suptitle (text)
    else:
      pylab.title (text)

  # plot computed MC estimators of statistics
  def stats_mcs (self, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, run=1, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):

    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting MC estimates of \'%s\'...' % qoi,
    sys.stdout.flush()

    levels = len (self.mlmc.config.levels)

    if not frame:
      self.figure (infolines, line, subplots=levels)

    self.title ('MC', qoi, title, sup=True)

    for mc in self.mlmc.mcs:

      if mc.config.type != self.mlmc.config.FINE:
        continue

      pylab.subplot ( 1, levels, mc.config.level + 1 )
      pylab.title ( 'level %d' % mc.config.level )

      self.stats ( qoi, mc.stats, extent, xorigin, yorigin, log, run, line )
      
      if axis != None:
        pylab.axis (axis)

    if infolines:
      self.infolines ()

    self.adjust (infolines, line, subplots=levels, sup=True)

    if not frame:
      self.draw (save, qoi, suffix='stats_mcs_' + suffix)

    print ' done.'

  # plot computed MC estimators of statistics
  def stats_mc (self, level, type=0, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, run=1, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):

    # some dynamic values
    if level  == 'finest':   level = self.mlmc.config.L
    if level  == 'coarsest': level = 0

    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting MC estimates of \'%s\' for level %d...' % (qoi, level),
    sys.stdout.flush()

    levels = len (self.mlmc.config.levels)

    if not frame:
      self.figure (infolines, line)

    self.title ('MC', qoi, title)

    mc = self.mlmc.mcs [ self.mlmc.config.pick [level] [type] ]
    self.stats ( qoi, mc.stats, extent, xorigin, yorigin, log, run, line )
    
    if axis != None:
      pylab.axis (axis)

    if infolines:
      self.infolines ()

    self.adjust (infolines, line)

    if not frame:
      self.draw (save, qoi, suffix='stats_mc' + suffix)

    print ' done.'

  # plot computed MC estimators of statistics for both types in separate sub-plots
  def stats_mcs_both (self, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, run=1, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):
    
    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting MC estimates (both types) of \'%s\'...' % qoi,
    sys.stdout.flush()
    
    levels = len (self.mlmc.config.levels)
    
    if not frame:
      if infolines:
        pylab.figure (figsize=(levels*6, 4+5))
      else:
        pylab.figure (figsize=(levels*6, 2*4))

    self.title ('MC', qoi, title, sup=True)

    for mc in self.mlmc.mcs:
      
      typestr = ['fine', 'coarse'] [mc.config.type]
      pylab.subplot ( 2, levels, mc.config.level + 1 + (mc.config.type == 1) * levels )
      pylab.title ( 'level %d %s' % (mc.config.level, typestr) )

      self.stats ( qoi, mc.stats, extent, xorigin, yorigin, log, run, line, legend=False )
      
      if axis != None:
        pylab.axis (axis)
    
    handles, labels = pylab.gcf().gca().get_legend_handles_labels()
    pylab.subplot (2, levels, 1 + levels)
    pylab.legend (handles, labels, loc='center')
    pylab.axis('off')

    if infolines:
      self.infolines ()

    self.adjust (infolines, line, sup=True)

    if not frame:
      self.draw (save, qoi, suffix='stats_mcs_both_' + suffix)

    print ' done.'

  # plot computed differences of MC estimators
  def stats_diffs (self, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=False, log=False, run=1, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):

    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting differences of MC estimates of \'%s\'...' % qoi,
    sys.stdout.flush()

    if self.mlmc.config.L == 0:
      print 'skipped (since L=0).'
      return

    if not frame:
      self.figure (infolines, line, subplots=self.mlmc.config.L)

    self.title ('MC differences', qoi, title, sup=True)

    for level, diff in enumerate (self.mlmc.diffs):

      if level == 0: continue
      pylab.subplot ( 1, self.mlmc.config.L, level)
      pylab.title ( 'level %d - level %d' % (level, level - 1) )
      
      self.stats ( qoi, diff, extent, xorigin, yorigin, log, run, line, centered=True )
      
      if axis != None:
        pylab.axis (axis)

    if infolines:
      self.infolines ()

    self.adjust (infolines, line, subplots=self.mlmc.config.L, sup=True)

    if not frame:
      self.draw (save, qoi, suffix='stats_diffs_' + suffix)

    print ' done.'

  # plot computed MC estimators and their differences
  def stats_mc_and_diffs (self, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, run=1, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):

    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting MC estimates AND differences of \'%s\'...' % qoi,
    sys.stdout.flush()

    levels = len (self.mlmc.config.levels)

    if not frame:
      if infolines:
        pylab.figure (figsize=(levels*6, 4+5))
      else:
        pylab.figure (figsize=(levels*6, 2*4))

    self.title ('MC and MC differences', qoi, title, sup=True)

    # MC estimates for each level (only type = 0)
    for mc in self.mlmc.mcs:

      if mc.config.type != 0:
        continue

      pylab.subplot ( 2, levels, mc.config.level + 1 )
      pylab.title ( 'level %d' % mc.config.level )

      self.stats ( qoi, mc.stats, extent, xorigin, yorigin, log, run, line, legend=False )

      if axis != None:
        pylab.axis (axis)

    # differences of MC estimates
    for level, diff in enumerate (self.mlmc.diffs):

      if level == 0:
        continue

      pylab.subplot ( 2, levels, level + 1 + levels )
      pylab.title ( 'level %d - level %d' % (level, level - 1) )

      self.stats ( qoi, diff, extent, xorigin, yorigin, log, run, line, centered=True )
      
      if axis != None:
        pylab.axis (axis)

    handles, labels = pylab.gcf().gca().get_legend_handles_labels()
    pylab.subplot (2, levels, 1 + levels)
    pylab.legend (handles, labels, loc='center')
    pylab.axis('off')

    if infolines:
      self.infolines ()

    self.adjust (infolines, line, sup=True)

    if not frame:
      self.draw (save, qoi, suffix='stats_mcs_and_diffs_' + suffix)

    print ' done.'

  # plot computed MLMC statistics
  def stats_mlmc (self, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, run=1, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):
    
    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting MLMC estimates of \'%s\'...' % qoi,
    sys.stdout.flush()
    
    if not self.mlmc.available:
      print ' NOT available.'
      return

    if not frame:
      self.figure (infolines, line)

    self.title ('MLMC', qoi, title)

    self.stats (qoi, self.mlmc.stats, extent, xorigin, yorigin, log, run, line)

    if axis != None:
      pylab.axis (axis)
    
    if infolines:
      self.infolines ()

    self.adjust (infolines, line)

    if not frame:
      self.draw (save, qoi, suffix='stats_mlmc_' + suffix)
    
    print ' done.'
  
  # plot results of one sample of the specified level and type
  def sample (self, level=None, type=0, sample=0, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, isolines=None, run=1, trendline=None, smoothen=41, label=None, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):

    # some dynamic values
    if level == None: level = 'finest'
    if level == 'finest':   level = self.mlmc.config.L
    if level == 'coarsest': level = 0
    
    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting sample %d of \'%s\' for level %d and type %d...' % (sample, qoi, level, type),
    sys.stdout.flush()

    if trendline == None:
      if '_pos' in qoi:
        trendline = 1
      else:
        trendline = 0

    results = self.mlmc.mcs [ self.mlmc.config.pick [level] [type] ] .results [sample]
    
    ts = numpy.array ( results.meta ['x'] )
    vs = numpy.array ( results.data [qoi] )
    
    # energy filter
    if base (qoi) == 'e':
      positions = []
      if '_pos_d_x' in qoi:
        max_d_x = 0.5 * numpy.sqrt (self.extent ** 2 + self.extent ** 2)
        positions = numpy.argwhere (vs > 0.9 * max_d_x)
      elif '_pos_d_y' in qoi:
        max_d_y = 0.5 * numpy.sqrt (self.extent ** 2 + self.extent ** 2)
        positions = numpy.argwhere (vs > 0.9 * max_d_y)
      elif '_pos_d_z' in qoi:
        max_d_z = 0.5 * numpy.sqrt (self.extent ** 2 + self.extent ** 2)
        positions = numpy.argwhere (vs > 0.9 * max_d_z)
      elif '_pos_d' in qoi:
        max_d = 0.5 * numpy.sqrt (self.extent ** 2 + self.extent ** 2 + self.extent ** 2)
        positions = numpy.argwhere (vs > 0.9 * max_d)
      ts = numpy.delete (ts, positions)
      vs = numpy.delete (vs, positions)
    
    # exclude first data point, if we are dealing with positions or vorticities
    if '_pos' in qoi or base (qoi) == 'W':
      ts = ts [1:]
      vs = vs [1:]
    
    # exclude more first data points for positions of densities
    if '_pos' in qoi and base (qoi) == 'r':
      ts = ts [3:]
      vs = vs [3:]
    
    if not frame:
      self.figure (infolines, line, subplots=1)

    if label == None:
      if '_pos' in qoi:
        label = 'distance'
      elif not frame:
        label = None
      elif not label:
        label = name (qoi)

    # 1-D plotting
    if self.dimensions == 1 or (self.dimensions == 2 and line != None):

      if self.dimensions == 2 and line != None:

        index = int ( line * results.meta ['NY'] )
        vs = vs [:, index]
        ts = results.meta ['x']

      if not (trendline and frame):
        pylab.plot (ts, vs, color=color(qoi), linestyle=style(run), alpha=alpha(run), label=label)

      if log:
        pylab.gca().set_yscale ('log', nonposy='clip')

      pylab.xlabel ('%s [%s]' % (results.meta ['xlabel'], results.meta ['xunit']))
      pylab.ylabel ('%s [%s]' % (name(qoi), unit(qoi)))

    # 2-D plotting
    elif self.dimensions == 2:

      # 2-D generic plotting
      if self.dimensions == 2 and isolines == None:

        data_extent = ( results.meta ['xrange'] [0], results.meta ['xrange'] [1], results.meta ['yrange'] [0], results.meta ['yrange'] [1] )

        vmax = extent [0] if extent != None else None
        vmin = extent [1] if extent != None else None
        cmap = matplotlib.colors.LinearSegmentedColormap.from_list ( 'gradient', ['white', color (qoi)] )
      
        if log:
          from matplotlib.colors import LogNorm
          norm = LogNorm (vmin=0, vmax=vmax)
        else:
          norm = None

        if results.name == 'shells':
          aspect = 'auto'
        else:
          aspect = 'equal'

        pylab.imshow (numpy.transpose (vs), cmap=cmap, origin='lower', aspect=aspect, norm=norm, extent=data_extent, interpolation='hermite', vmin=vmin, vmax=vmax)
        pylab.colorbar ()

        if axis != None:
          pylab.axis (axis)
    
      # 2-D isolines plotting
      elif self.dimensions == 2 and isolines != None:

        data_extent = ( results.meta ['xrange'] [0], results.meta ['xrange'] [1], results.meta ['yrange'] [0], results.meta ['yrange'] [1] )

        if label == None:
          label = 'contour at %s' % ( ' '.join ( [ '%.2f' % isoline for isoline in isolines ] ) )
      
        pylab.contour (vs, origin='lower', aspect='equal', extent=data_extent, levels=isolines, colors=color(qoi), linestyles=style(run), alphas=alpha(run), linewidths=1, label=label)

        if axis != None:
          pylab.axis (axis)

      pylab.xlabel ('%s [%s]' % (results.meta ['xlabel'], results.meta ['xunit']))
      pylab.ylabel ('%s [%s]' % (results.meta ['ylabel'], results.meta ['yunit']))

    # remaining cases
    if self.dimensions > 2:
      self.mlmc.helpers.warning ('Only 1-D and 2-D plotting are available')
      return
    
    # add trendline (if specified or if dealing with positions)
    if trendline:
      ls = filter (vs, width=smoothen)
      if not frame:
        label = 'trendline'
      if len (ls) == len (ts):
        pylab.plot  (ts, ls, color=color('trendline'), linestyle=style(run), alpha=alpha(run), label=label)
      else:
        print
        print ' :: WARNING: computing trendline failed (NaN\'s present? Too short?)'
    
    if title:
      title = '%s %s' % (name (qoi), results.name)
      if 't' in results.meta and not hasattr ( results.meta ['t'], '__iter__'):
        title += (' | ' + self.timeformat + ' %s') % (results.meta ['t'], unit ('t'))
      if not self.mlmc.config.deterministic:
        title += ' | L%d T%d S%d' % (level, type, sample)
      pylab.title (title)
    
    self.helper_lines (qoi, run)
    
    self.adjust_axes (qoi, extent, xorigin, yorigin, line)
    
    if infolines:
      self.infolines ()
    
    self.adjust (infolines, line)
    
    if not frame:
      self.draw (save, qoi, suffix = suffix + '_%s_L%d_T%d_S%d' % (results.name, level, type, sample))

    print ' done.'

  '''
  # plot the first sample of the finest level and type 0
  # used mainly for deterministic runs
  def plot (self, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, isolines=None, run=1, trendline=None, smoothen=41, label=None, line=None, frame=False, title=True, axis=None, suffix='autosave', save=None):
    
    level  = 'finest'
    type   = 0
    sample = 0

    self.sample (level, type, sample, qoi, infolines, extent, xorigin, yorigin, log, isolines, run, trendline, smoothen, label, line, frame, title, axis, suffix, save)
  '''

  # plot results of all samples (ensemble) of the specified level and type 
  def ensemble (self, level, type=0, qoi=None, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, legend=4, limit=1024, line=None, save=None):

    if self.dimensions > 1 and line == None:
      self.mlmc.helpers.warning ('Ensemble plots are not available for multi-dimensional data [unless \'line\' is specifed]')

    # some dynamic values
    if level  == 'finest':   level  = self.mlmc.config.L
    if level  == 'coarsest': level  = 0
    
    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting ensemble of \'%s\' for level %d and type %d (limit set to %d)...' % (qoi, level, type, limit),
    sys.stdout.flush()

    xend = float('nan')

    self.figure (infolines, line, subplots=1)

    count = 0
    for sample in self.mlmc.config.samples.indices.loaded [level]:

      if count == limit:
        break
      
      results = self.mlmc.mcs [ self.mlmc.config.pick [level] [type] ] .results [sample]

      if results == None:
        continue
      else:
        count += 1

      ts = numpy.array ( results.meta ['x'] )
      vs = numpy.array ( results.data [qoi] )

      xend = max (xend, numpy.max(ts))
      
      # exclude first data point, if we are dealing with positions
      if '_pos' in qoi:
        ts = ts [1:]
        vs = vs [1:]

      pylab.plot (ts, vs, label=str(sample), linewidth=1)

    if log:
      pylab.gca().set_yscale ('log', nonposy='clip')
    
    pylab.title ( 'samples of %s %s | L%d T%d' % (name (qoi), self.mlmc.config.solver.dataclass.name, level, type) )
    
    pylab.xlabel ('%s [%s]' % (name('t'), unit('t')))
    pylab.ylabel ('%s [%s]' % (name(qoi), unit(qoi)))
    
    self.helper_lines (qoi)
    
    self.adjust_axes (qoi, extent, xorigin, yorigin, line)
    
    if min (limit, self.mlmc.config.samples.counts.loaded [level]) <= legend:
      pylab.legend (loc='best')
    
    if infolines:
      self.infolines ()
    
    self.adjust (infolines, line)
    
    self.draw (save, qoi, suffix='ensemble_%d_%d' % (level, type))
    
    print ' done.'

  # plot results of all samples (ensemble) of all levels
  def ensembles (self, qoi=None, both=True, infolines=False, extent=None, xorigin=True, yorigin=True, log=False, limit=1024, valid=False, line=None, save=None):

    if self.dimensions > 1 and line == None:
      self.mlmc.helpers.warning ('Ensemble plots are not available for multi-dimensional data [unless \'line\' is specifed]')

    if not qoi: qoi = self.mlmc.config.solver.qoi

    print ' :: INFO: Plotting ensembles of \'%-20s\' for all levels (limit set to %d)...' % (qoi, limit),
    sys.stdout.flush()
    
    levels = len (self.mlmc.config.levels)

    self.figure (infolines, line, subplots=levels)

    pylab.suptitle ( 'samples of %s %s' % (name (qoi), self.mlmc.config.solver.dataclass.name) )

    for level in self.mlmc.config.levels:

      pylab.subplot ( 1, levels, level + 1 )

      xend = float('nan')

      count = 0
      for sample in range (self.mlmc.config.samples.counts.computed [level]):

        if valid and sample in self.mlmc.config.indices.invalid [level]:
          continue

        if count == limit:
          break

        for type in self.mlmc.config.types (level):

          if type == self.mlmc.config.COARSE and not both:
            continue

          results = self.mlmc.mcs [ self.mlmc.config.pick [level] [type] ] .results [sample]

          if results == None:
            continue
          else:
            count += 1

          ts = numpy.array ( results.meta ['x'] )
          vs = numpy.array ( results.data [qoi] )

          xend = max (xend, numpy.max(ts))

          # exclude first data point, if we are dealing with positions
          if '_pos' in qoi:
            ts = ts [1:]
            vs = vs [1:]
          
          if type == self.mlmc.config.FINE:
            line, = pylab.plot  (ts, vs, linewidth=1, alpha=1.0 )
          else:
            try:
              color = line.get_color()
              pylab.plot  (ts, vs, linewidth=1, alpha=0.3, color=color )
            except:
              pylab.plot  (ts, vs, linewidth=1, alpha=0.3 )

      if log:
        pylab.gca().set_yscale ('log', nonposy='clip')
      
      pylab.xlabel ('%s [%s]' % (name('t'), unit('t')))
      pylab.ylabel ('%s [%s]' % (name(qoi), unit(qoi)))
      pylab.title ( 'level %d' % level)

      self.helper_lines (qoi)

      self.adjust_axes (qoi, extent, xorigin, yorigin, line)

    if infolines:
      self.infolines ()

    self.adjust (infolines, line, subplots=levels)

    self.draw (save, qoi, suffix='ensembles' + ('_both' if both else ''))

    print ' done.'

  def diagram (self, solver, params, param_name, param_unit, outputfilenames, qoi=None, ref_file=None, ref_label=None, infolines=False, extent=None, xorigin=True, yorigin=True, logx=False, run=1, label=None, frame=False, save=None):
    
    if not qoi: qoi = solver.qoi

    print ' :: INFO: Plotting diagram of \'%-20s\'...' % qoi,
    sys.stdout.flush()
    
    vs = []
    for outputfilename in outputfilenames:
      results = solver.load (file=outputfilename)
      if '_time' in qoi:
        vs.append ( results.meta ['t'] [ numpy.argmax (results.data [qoi[:-5]]) ] )
      else:
        vs.append ( numpy.max ( results.data [qoi] ) )

    if not frame:
      self.figure (infolines, subplots=1)
    
    if label == None:
      label = name (qoi)
    
    if logx:
      pylab.semilogx (params, vs, color=color(qoi), linestyle=style(run), marker='o', markerfacecolor='w', markeredgecolor=color(qoi), alpha=alpha(run), label=label)
    else:
      pylab.plot (params, vs, color=color(qoi), linestyle=style(run), marker='o', markerfacecolor='w', markeredgecolor=color(qoi), alpha=alpha(run), label=label)
    
    if ref_file:
      results = solver.load (file=ref_file)
      if '_time' in qoi:
        v_ref = results.meta ['t'] [ numpy.argmax (results.data [qoi[:-5]]) ]
      else:
        v_ref = numpy.max ( results.data [qoi] )
      pylab.axhline (y=v_ref, xmin=params[0], xmax=params[-1], color=color(qoi), linestyle=style(run), alpha=0.5, label=ref_label)
    
    pylab.xlabel ('%s [%s]' % ( param_name, param_unit) )
    pylab.ylabel ('%s [%s]' % ( name (qoi), unit (qoi) ))
    pylab.title  ('Diagram of %s' % name (qoi))
    
    self.helper_lines (qoi, run)
    
    yend = 1.05 * numpy.max (vs)
    self.adjust_axes (qoi, extent, xorigin, yorigin, yend=yend)
    
    if infolines:
      self.infolines ()
    
    self.adjust (infolines)
    
    if not frame:
      self.draw (None, save, qoi, legend=True, suffix='diagram')

  # plot samples
  def samples (self, infolines=False, warmup=True, optimal=True, run=1, frame=False, fill=1, save=None):

    print ' :: INFO: Plotting samples...',
    sys.stdout.flush()

    # === load all required data

    levels           = self.mlmc.config.levels
    qoi              = self.mlmc.config.solver.qoi

    # === plot

    if not frame:
      self.figure (infolines, subplots=1)

    # plot number of samples

    basevalue = 0.3
    baseline  = [basevalue for level in levels]
    pylab.semilogy (levels, self.mlmc.config.samples.history ['combined'] [0], color=color_params('warmup'), linestyle=style(run), marker='+', label='warmup')
    if fill:
      pylab.fill_between (levels, baseline, self.mlmc.config.samples.history ['combined'] [0], facecolor=color_params('warmup'), alpha=0.5, linewidth=0.0)
    if self.mlmc.config.iteration > 0:
      pylab.semilogy (levels, self.mlmc.config.samples.counts.combined, color=color_params('samples'), linestyle=style(run), alpha=alpha(run), marker='x', label='final')
      if fill:
        pylab.fill_between (levels, self.mlmc.config.samples.history ['combined'] [0], self.mlmc.config.samples.counts.combined, facecolor=color_params('samples'), alpha=0.5, linewidth=0.0)
    if optimal and self.mlmc.config.iteration > 0:
      pylab.semilogy (levels, self.mlmc.config.samples.counts.optimal, color=color_params('optimal'), linestyle=style(run), marker='|', label='optimal (~%d%% less work)' % (100 * self.mlmc.config.samples.overhead))
    pylab.title  ('Number of samples')
    pylab.ylabel ('number of samples')
    pylab.xlabel ('mesh level')
    levels_extent (levels)
    pylab.ylim   (ymin=basevalue)
    pylab.axhline (y=1, color='black', linestyle='-', linewidth=1, alpha=0.7)
    pylab.axhline (y=2, color='black', linestyle='-', linewidth=1, alpha=0.5)
    pylab.axhline (y=3, color='black', linestyle='-', linewidth=1, alpha=0.3)
    pylab.axhline (y=4, color='black', linestyle='-', linewidth=1, alpha=0.1)

    if not frame:
      pylab.legend (loc='upper right')

    self.adjust (infolines)

    if infolines:
      show_info(self)

    if not frame:
      self.draw (save, qoi, suffix='analytics_samples')

    print ' done.'

  # plot budget
  def budget (self, infolines=False, warmup=1, optimal=1, run=1, frame=False, total=1, fill=1, normalization=1e6, unit='million', save=None):

    print ' :: INFO: Plotting budget...',
    sys.stdout.flush()

    # === load all required data

    levels           = self.mlmc.config.levels
    qoi              = self.mlmc.config.solver.qoi
    
    budget_warmup      = [ self.mlmc.config.samples.history ['combined'] [0] [level] * self.mlmc.config.samples.pairworks [level] / normalization for level in levels ]
    budget_final       = [ self.mlmc.config.samples.counts.combined          [level] * self.mlmc.config.samples.pairworks [level] / normalization for level in levels ]
    budget_optimal     = [ self.mlmc.config.samples.counts.optimal           [level] * self.mlmc.config.samples.pairworks [level] / normalization for level in levels ]
    budget_total       = sum (budget_final)

    # === plot

    if not frame:
      self.figure (infolines, subplots=1)

    # plot budget

    basevalue = 0
    baseline  = [basevalue for level in levels]
    if warmup:
      pylab.plot (levels, budget_warmup, color=color_params('warmup'), linestyle=style(run), marker='+', label='warmup')
      if fill:
        pylab.fill_between (levels, baseline, budget_warmup, facecolor=color_params('warmup'), alpha=0.5, linewidth=0.0)
    if self.mlmc.config.iteration > 0:
      pylab.plot (levels, budget_final, color=color_params('budget'), linestyle=style(run), alpha=alpha(run), marker='x', label='final')
      if fill:
        pylab.fill_between (levels, budget_warmup, budget_final, facecolor=color_params('budget'), alpha=0.5, linewidth=0.0)
    if total:
      pylab.axhline (y=budget_total, color=color_params('total'), linestyle=style(run), alpha=alpha(run)/2, label='total: %.1f %s' % (budget_total, unit))
    if optimal and self.mlmc.config.iteration > 0:
      pylab.semilogy (levels, budget_optimal, color=color_params('optimal'), linestyle=style(run), marker='|', label='optimal (~%d%% less work)' % (100 * self.mlmc.config.samples.overhead))
    pylab.title  ('Computational budget')
    pylab.ylabel ('budget [%s core hours]' % unit)
    pylab.xlabel ('mesh level')
    levels_extent (levels)
    pylab.ylim   (ymin=basevalue)

    if not frame:
      pylab.legend (loc='center left')

    self.adjust (infolines)

    if infolines:
      show_info(self)

    if not frame:
      self.draw (save, qoi, suffix='analytics_budget')

    print ' done.'

  # plot indicators (diffs)
  def diffs (self, exact=None, infolines=False, run=1, frame=False, tol=False, coarsest=False, accuracies=True, cutoff=1e-3, save=None):
    
    print ' :: INFO: Plotting diffs...',
    sys.stdout.flush()
    
    # === load all required data

    # use only levels with true differences 
    levels = self.mlmc.config.levels
    if not coarsest and len (levels) > 1:
      levels = levels  [ 1 : ]
    
    mean_diff_measured         = numpy.abs (self.mlmc.indicators.mean_diff         ['measured'] [levels])
    variance_diff_measured     = numpy.abs (self.mlmc.indicators.variance_diff     ['measured'] [levels])
    mean_diff_accuracy         = numpy.abs (self.mlmc.indicators.mean_diff         ['accuracy'] [levels])
    variance_diff_accuracy     = numpy.abs (self.mlmc.indicators.variance_diff     ['accuracy'] [levels])
    mean_diff_infered          = numpy.abs (self.mlmc.indicators.mean_diff         ['infered']  [levels])
    variance_diff_infered      = numpy.abs (self.mlmc.indicators.variance_diff     ['infered']  [levels])
    mean_diff_opt_infered      = numpy.abs (self.mlmc.indicators.mean_diff_opt     ['infered']  [levels])
    variance_diff_opt_infered  = numpy.abs (self.mlmc.indicators.variance_diff_opt ['infered']  [levels])
    #TOL           = self.mlmc.config.samples.tol
    NORMALIZATION = self.mlmc.errors.normalization
    qoi           = self.mlmc.config.solver.qoi

    # === compute error using the exact solution mean_exact
    
    if exact:
      
      # TODO: this needs to be reviewed
      error = numpy.abs ( exact - self.mlmc.stats [ qoi ] ) / NORMALIZATION
    
    # === plot
    
    if not frame:
      self.figure (infolines, subplots=2)
    
    # plot mean diffs (measured, infered and optimized)
    
    pylab.subplot(121)
    if accuracies:
      color = brighten (color_params('epsilon'), factor=0.7)
      pylab.errorbar (levels, mean_diff_measured / NORMALIZATION, yerr=mean_diff_accuracy / NORMALIZATION, fmt='o', capsize=6, color=color, markeredgecolor=color, markerfacecolor='w', alpha=alpha(run), label='measured')
    else:
      pylab.semilogy (levels, mean_diff_measured / NORMALIZATION, color=color_params('epsilon'), linestyle=style(3), alpha=alpha(run), marker='x', label='measured')
    pylab.semilogy (levels, mean_diff_infered     / NORMALIZATION, color=color_params('epsilon'), linestyle=style(1), alpha=alpha(run), marker='x', label='infered')
    pylab.semilogy (levels, mean_diff_opt_infered / NORMALIZATION, color=color_params('epsilon'), linestyle=style(2), alpha=alpha(run), marker='x', label='optimized')
    if run == 1:
      if exact:
        pylab.axhline (y=error, xmin=levels[0], xmax=levels[-1], color=color_params('error'), linestyle=style(run), alpha=0.3, label='MLMC error (%1.1e) for K = 1' % error)
      #pylab.axhline   (y=TOL,   xmin=levels[0], xmax=levels[-1], color=color_params('tol'),   linestyle=style(run), alpha=0.6, label='TOL = %1.1e' % TOL)
    pylab.title  ('Rel. difference means for Q = %s' % name (qoi))
    pylab.ylabel (r'|rel. mean of $\alpha_\ell Q_\ell - \alpha_{\ell-1} Q_{\ell-1}$|')
    pylab.xlabel ('mesh level')
    '''
    ymin = numpy.min ( [ numpy.min (mean_diff_measured), numpy.min (mean_diff_infered), numpy.min (mean_diff_opt_infered) ] ) / NORMALIZATION
    ymax = numpy.max ( [ numpy.max (mean_diff_measured), numpy.max (mean_diff_infered), numpy.max (mean_diff_opt_infered) ] ) / NORMALIZATION
    if accuracies:
      ymin = min ( ymin, numpy.min (mean_diff_measured - mean_diff_accuracy) / NORMALIZATION )
      ymax = max ( ymax, numpy.max (mean_diff_measured + mean_diff_accuracy) / NORMALIZATION )
    adjust_extent ([ymin, ymax], factor=1.5)
    '''
    levels_extent (levels)
    pylab.legend (loc='lower left')
    
    # plot variance diffs (measured, infered and optimized)
    
    pylab.subplot(122)
    if accuracies:
      color = brighten (color_params('sigma'), factor=0.7)
      pylab.errorbar (levels, numpy.sqrt (variance_diff_measured)    / NORMALIZATION, yerr=variance_diff_accuracy / NORMALIZATION, fmt='o', capsize=6, color=color, markeredgecolor=color, markerfacecolor='w', alpha=alpha(run), label='measured')
    else:
      pylab.semilogy (levels, numpy.sqrt (variance_diff_measured)    / NORMALIZATION, color=color_params('sigma'), linestyle=style(3), alpha=alpha(run), marker='x', label='measured')
    pylab.semilogy (levels, numpy.sqrt (variance_diff_infered)     / NORMALIZATION, color=color_params('sigma'), linestyle=style(1), alpha=alpha(run), marker='x', label='infered')
    pylab.semilogy (levels, numpy.sqrt (variance_diff_opt_infered) / NORMALIZATION, color=color_params('sigma'), linestyle=style(2), alpha=alpha(run), marker='x', label='optimized')
    #if run == 1:
    #  pylab.axhline (y=TOL, xmin=levels[0], xmax=levels[-1], color=color_params('tol'), linestyle=style(run), alpha=0.6, label='TOL = %1.1e' % TOL)
    pylab.title  ('Rel. difference std. devs. for Q = %s' % name (qoi))
    pylab.ylabel (r'rel. std. dev. of $\alpha_\ell Q_\ell - \alpha_{\ell-1} Q_{\ell-1}$')
    pylab.xlabel ('mesh level')
    '''
    ymin = numpy.sqrt ( numpy.min ( [ numpy.min (variance_diff_measured), numpy.min (variance_diff_infered), numpy.min (variance_diff_opt_infered) ] ) ) / NORMALIZATION
    ymax = numpy.sqrt ( numpy.max ( [ numpy.max (variance_diff_measured), numpy.max (variance_diff_infered), numpy.max (variance_diff_opt_infered) ] ) ) / NORMALIZATION
    if accuracies:
      ymin = min ( ymin, numpy.min (numpy.sqrt (variance_diff_measured) - variance_diff_accuracy) / NORMALIZATION )
      ymax = max ( ymax, numpy.max (numpy.sqrt (variance_diff_measured) + variance_diff_accuracy) / NORMALIZATION )
    adjust_extent ([ymin, ymax], factor=1.5)
    '''
    levels_extent (levels)
    pylab.legend (loc='lower left')
    
    self.adjust (infolines, subplots=2)
    
    if infolines:
      show_info(self)
    
    if not frame:
      self.draw (save, qoi, suffix='analytics_diffs')

    print ' done.'
  
  # plot indicators
  def indicators (self, exact=None, infolines=False, run=1, frame=False, tol=False, accuracies=True, save=None):
    
    print ' :: INFO: Plotting indicators...',
    sys.stdout.flush()
    
    # === load all required data

    mean_measured         = numpy.abs (self.mlmc.indicators.mean     [self.mlmc.config.FINE] ['measured'])
    variance_measured     = numpy.abs (self.mlmc.indicators.variance [self.mlmc.config.FINE] ['measured'])
    mean_accuracy         = numpy.abs (self.mlmc.indicators.mean     [self.mlmc.config.FINE] ['accuracy'])
    variance_accuracy     = numpy.abs (self.mlmc.indicators.variance [self.mlmc.config.FINE] ['accuracy'])
    mean_infered          = numpy.abs (self.mlmc.indicators.mean     [self.mlmc.config.FINE] ['infered'])
    variance_infered      = numpy.abs (self.mlmc.indicators.variance [self.mlmc.config.FINE] ['infered'])
    #TOL           = self.mlmc.config.samples.tol
    NORMALIZATION = self.mlmc.errors.normalization
    qoi           = self.mlmc.config.solver.qoi
    levels        = self.mlmc.config.levels
    
    # === compute error using the exact solution mean_exact
    
    if exact:
      
      # TODO: this needs to be reviewed
      error = numpy.abs ( exact - self.mlmc.stats [ qoi ] ) / NORMALIZATION
    
    # === plot
    
    if not frame:
      self.figure (infolines, subplots=2)
    
    # plot means (measured, infered and optimized)
    
    pylab.subplot(121)
    if accuracies:
      color = brighten (color_params('epsilon'), factor=0.7)
      pylab.errorbar (levels, mean_measured / NORMALIZATION, yerr=mean_accuracy / NORMALIZATION, fmt='o', capsize=6, color=color, markeredgecolor=color, markerfacecolor='w', alpha=alpha(run), label='measured')
    else:
      pylab.plot (levels, mean_measured / NORMALIZATION, color=color_params('epsilon'), linestyle=style(3), alpha=alpha(run), marker='x', label='measured')
    pylab.plot (levels, mean_infered / NORMALIZATION, color=color_params('epsilon'), linestyle=style(1), alpha=alpha(run), marker='x', label='infered')
    if run == 1:
      if exact:
        pylab.axhline (y=error, xmin=levels[0], xmax=levels[-1], color=color_params('error'), linestyle=style(run), alpha=0.3, label='MLMC error (%1.1e) for K = 1' % error)
      #pylab.axhline   (y=TOL,   xmin=levels[0], xmax=levels[-1], color=color_params('tol'),   linestyle=style(run), alpha=0.6, label='TOL = %1.1e' % TOL)
    pylab.title  ('Rel. level means for Q = %s' % name (qoi))
    pylab.ylabel (r'|rel. mean of $Q_\ell$|')
    pylab.xlabel ('mesh level')
    '''
    ymin = numpy.min ( [ numpy.min (mean_measured), numpy.min (mean_infered) ] ) / NORMALIZATION
    ymax = numpy.max ( [ numpy.max (mean_measured), numpy.max (mean_infered) ] ) / NORMALIZATION
    if accuracies:
      ymin = min ( ymin, numpy.min (mean_measured - mean_accuracy) / NORMALIZATION )
      ymax = max ( ymax, numpy.max (mean_measured + mean_accuracy) / NORMALIZATION )
    adjust_extent ([ymin, ymax], factor=1.5)
    '''
    pylab.gca().set_ylim (bottom = 0.0)
    pylab.gca().set_ylim (top    = 1.5)
    levels_extent (levels)
    pylab.legend (loc='lower left')
    
    # plot standard deviations (measured, infered and optimized)
    
    pylab.subplot(122)
    if accuracies:
      color = brighten (color_params('sigma'), factor=0.7)
      pylab.errorbar (levels, numpy.sqrt (variance_measured) / NORMALIZATION, yerr=variance_accuracy / NORMALIZATION, fmt='o', capsize=6, color=color, markeredgecolor=color, markerfacecolor='w', alpha=alpha(run), label='measured')
    else:
      pylab.plot (levels, numpy.sqrt (variance_measured) / NORMALIZATION, color=color_params('sigma'), linestyle=style(3), alpha=alpha(run), marker='x', label='measured')
    pylab.plot (levels, numpy.sqrt (variance_infered)  / NORMALIZATION, color=color_params('sigma'), linestyle=style(1), alpha=alpha(run), marker='x', label='infered')
    #if run == 1:
    #  pylab.axhline (y=TOL, xmin=levels[0], xmax=levels[-1], color=color_params('tol'), linestyle=style(run), alpha=0.6, label='TOL = %1.1e' % TOL)
    pylab.title  ('Rel. level std. devs. for Q = %s' % name (qoi))
    pylab.ylabel (r'rel. std. dev. of $Q_\ell$')
    pylab.xlabel ('mesh level')
    '''
    ymin = numpy.sqrt ( numpy.min ( [ numpy.min (variance_measured), numpy.min (variance_infered) ] ) ) / NORMALIZATION
    ymax = numpy.sqrt ( numpy.max ( [ numpy.max (variance_measured), numpy.max (variance_infered) ] ) ) / NORMALIZATION
    if accuracies:
      ymin = min ( ymin, numpy.min (numpy.sqrt (variance_measured) - variance_accuracy) / NORMALIZATION )
      ymax = max ( ymax, numpy.max (numpy.sqrt (variance_measured) + variance_accuracy) / NORMALIZATION )
    adjust_extent ([ymin, ymax], factor=1.5)
    '''
    pylab.gca().set_ylim (bottom = 0.0)
    pylab.gca().set_ylim (top    = 1.5)
    levels_extent (levels)
    pylab.legend (loc='upper left')
    
    self.adjust (infolines, subplots=2)
    
    if infolines:
      show_info(self)
    
    if not frame:
      self.draw (save, qoi, suffix='analytics_indicators')

    print ' done.'

  # plot correlations
  def correlations (self, exact=None, infolines=False, run=1, frame=False, tol=False, save=None):

    print ' :: INFO: Plotting correlations...',
    sys.stdout.flush()

    # === load all required data

    correlation_measured = self.mlmc.indicators.correlation ['measured']
    correlation_infered  = self.mlmc.indicators.correlation ['infered']
    levels = self.mlmc.config.levels
    qoi    = self.mlmc.config.solver.qoi

    # === plot

    if not frame:
      self.figure (infolines, subplots=1)

    # plot correlations

    color = color_params('correlation')
    pylab.plot (levels, correlation_measured, color=color, linestyle='',       alpha=alpha(run), marker='o', markeredgecolor=color, markerfacecolor='w', label='measured')
    pylab.plot (levels, correlation_infered,  color=color, linestyle=style(1), alpha=alpha(run), marker='x', label='infered')
    if run == 1:
      #pylab.axhline (y=0.5, xmin=levels[0], xmax=levels[-1], color=color_params('tol'), linestyle='-', linewidth=2, alpha=0.6, label='correlation = 1/2')
      pylab.axhline (y=0.0, xmin=levels[0], xmax=levels[-1], color='black', linestyle='-', linewidth=2, alpha=0.3)
      pylab.axhline (y=1.0, xmin=levels[0], xmax=levels[-1], color='black', linestyle='-', linewidth=2, alpha=0.3)
    pylab.title  ('Level correlations for Q = %s' % name (qoi))
    pylab.ylabel (r'correlation of $Q_\ell$ and $Q_{\ell-1}$')
    pylab.xlabel ('mesh level')
    pylab.ylim ( [ -0.1, 1.1 * max (1.0, max (correlation_measured)) ] )
    levels_extent (levels)
    pylab.legend (loc='lower center')

    self.adjust (infolines, subplots=1)

    if infolines:
      show_info(self)

    if not frame:
      self.draw (save, qoi, suffix='analytics_correlations')

    print ' done.'

  # plot coefficients
  def coefficients (self, exact=None, infolines=False, run=1, frame=False, tol=False, save=None):

    print ' :: INFO: Plotting coefficients...',
    sys.stdout.flush()

    # === load all required data

    coefficients = self.mlmc.indicators.coefficients.values
    levels       = self.mlmc.config.levels
    qoi          = self.mlmc.config.solver.qoi

    # === plot

    if not frame:
      self.figure (infolines, subplots=1)

    # plot coefficients

    pylab.plot (levels, coefficients, color=color_params('coefficient'), linestyle=style(run), alpha=alpha(run), marker='x', label='level coefficients')
    if self.mlmc.errors.speedup_ocv != None:
      pylab.plot ([], [], color='w', alpha=0, linewidth=0, label='speedup: %.2fx' % self.mlmc.errors.speedup_ocv)
    if run == 1:
      pylab.axhline (y=0.0, xmin=levels[0], xmax=levels[-1], color='black', linestyle='-', linewidth=2, alpha=0.3)
      pylab.axhline (y=1.0, xmin=levels[0], xmax=levels[-1], color='black', linestyle='-', linewidth=2, alpha=0.3)
    pylab.title  ('Level coefficients for Q = %s' % name (qoi))
    pylab.ylabel ('coefficient')
    pylab.xlabel ('mesh level')
    pylab.ylim ( [ -0.1, 1.1 * max (1.0, max (coefficients)) ] )
    levels_extent (levels)
    pylab.legend (loc='lower center')

    self.adjust (infolines, subplots=1)

    if infolines:
      show_info(self)

    if not frame:
      self.draw (save, qoi, suffix='analytics_coefficients')
    
    print ' done.'

  # plot errors
  def errors (self, infolines=False, warmup=1, run=1, frame=False, total=1, fill=1, save=None):
    
    print ' :: INFO: Plotting errors...',
    sys.stdout.flush()

    if not self.mlmc.errors.available:
      print ' NOT available.'
      return

    # === load all required data

    #TOL              = self.mlmc.config.samples.tol
    levels           = self.mlmc.config.levels
    qoi              = self.mlmc.config.solver.qoi
    
    # === plot
    
    if not frame:
      self.figure (infolines, subplots=1)
    
    # plot relative sampling error
    if warmup:
      pylab.semilogy (levels, self.mlmc.errors.history ['relative_error'] [0], color=color_params('warmup'), linestyle=style(run), alpha=alpha(run), marker='+', label='warmup')
    if self.mlmc.config.iteration > 0:
      pylab.semilogy (levels, self.mlmc.errors.relative_error, color=color_params('errors'), linestyle=style(run), alpha=alpha(run), marker='x', label='final')
      if fill:
        pylab.fill_between (levels, self.mlmc.errors.relative_error, self.mlmc.errors.history ['relative_error'] [0], facecolor=color_params('errors'), alpha=0.5, linewidth=0.0)
    if total:
      pylab.axhline (y=self.mlmc.errors.total_relative_error, color=color_params('error'), linestyle=style(run), alpha=alpha(run)/2, label='total: %.1e' % self.mlmc.errors.total_relative_error)
    #if run == 1:
    #  pylab.axhline  (y=TOL, color=color_params('tol'), linestyle=style(run), alpha=0.6, label='required TOL = %1.1e' % TOL )
    if self.mlmc.errors.speedup_mlmc != None:
      pylab.plot ([], [], color='w', alpha=0, linewidth=0, label='speedup: %.1fx' % self.mlmc.errors.speedup_mlmc)
    pylab.title  ('Rel. sampling errors for Q = %s' % name (qoi))
    pylab.ylabel (r'$\sqrt{\operatorname{Var} ( \alpha_\ell Q_\ell - \alpha_{\ell-1} Q_{\ell-1} ) / M_\ell}$')
    pylab.xlabel ('mesh level')
    levels_extent (levels)
    #pylab.ylim   (ymax=1.5*TOL)
    pylab.legend (loc='lower left')
    
    self.adjust (infolines)
    
    if infolines:
      show_info(self)
    
    if not frame:
      self.draw (save, qoi, suffix='analytics_errors')

    print ' done.'
  
  def encode (self, directory='mov/frames', filenames=None, options='', duration=None, framerate=30, background='white', pause=3, verbose=1, suffix='autosave', extension='mp4', save=None):

    import os, glob
    print
    
    if filenames == None:
      filenames = '%s_frame*.png' % suffix

    filepaths = os.path.join (directory, filenames)

    # get frames
    files = sorted ( glob.glob (filepaths) )

    # count frames
    frames = len (files)
    print " :: Frames: %d" % frames
    
    # check if any file exists
    if frames == 0:
      print ( ' :: ERROR: no files found in %s' % directory )
      print ( '    mathichg %s' % filenames )
      sys.exit()
    
    # set fps
    if not duration:
      duration = float(frames) / framerate
    fps = float(frames) / duration
    
    # copy last frame several times
    if pause:
      stills = int ( round (fps * pause) )
      import shutil
      print ' :: Multiplying last frame...',
      for still in range (stills):
        shutil.copy (files [-1], files [-1] + '.still%04d' % still)
      print ' done.'
    
    # report frame rates
    print " :: Frame rate: %.1f (%.1f X)" % (fps, fps / 30.0)
    if fps < 24:
      print "  : -> consider increasing number of input snapshots to increase the frame rate!"
    
    # configure file name
    if save == None and self.autosave:
      save = figname (figpath=self.movpath, dataclass=self.mlmc.config.solver.dataclass.name, suffix=suffix, extension=extension)

    print
    print ' :: Encoding...'
    if not verbose:
      options += ' -loglevel warning'
    size = execute ('convert %s -print "%%wx%%h" /dev/null' % files [0], verbose=0, pipe=1)
    print ' : -> size: ' + size
    filter = '-f lavfi -i color=c=%s:s=%s' % (background, size)
    filter = ''
    cmd = 'ffmpeg -r %f %s -pattern_type glob -i \'%s\' -c:v libx264 -r 60 -profile:v high -pix_fmt yuv420p -preset slow -crf 18 -threads 0 %s -y %s' % (fps, filter, filepaths, options, save)
    if not verbose:
      cmd += ' >> /dev/null &> /dev/null'
    execute (cmd, verbose=verbose)
    print
    print ' :: done.'
    print
  
  def rp_approximated (self, r, p0_l=100, p0_g=0.0234, rho_l=1000):
    tc = 0.914681 * r * numpy.sqrt ( rho_l / (p0_l - p0_g) )
    rh = lambda t : r * numpy.power (tc ** 2 - t ** 2, 2.0/5.0) / numpy.power (tc ** 2, 2.0/5.0)
    return tc, rh

  def rp_integrated (self, r, p0_l=100, p0_g=0.0234, rho_l=1000, rho0_g=1, gamma=1.4, tend=None, mu=0, S=0, model=None):
    if model == None:
      import rp
      model = rp.OptPL2()
    dr0 = 0
    [ts, rs, ps, drs, name] = rp.integrate (r, p0_l, p0_g, rho_l, rho0_g, gamma, tend, dr0, mu, S, model)
    return numpy.array(ts), numpy.array(rs), numpy.array(ps), numpy.array(drs), name

  # plot Rayleigh Plesset
  def rp (self, r, p0_l=100, p0_g=0.0234, rho_l=1000, rho0_g=1, gamma=1.4, mu=0, S=0, count=1, color=None, approximation=False, model='OptPL2', run=1, frame=False, save=None):

    import rp

    if r == None:
      r = numpy.array ( self.mlmc.mcs [ self.mlmc.config.pick [self.mlmc.config.L] [0] ] .results [0] .data ['Req'] ) [0]
      if count != 1:
        r /= count ** (1.0/3.0)
    
    if not frame:
      self.figure (infolines=False, subplots=1)
    
    if approximation:
      tc, rh = self.rp_approximated (r, p0_l, p0_g, rho_l)
      ts = numpy.linspace (0, tc, 10000)
      rs = rp(ts)
      label = 'Rayleigh-Plesset (approx.)'
      if color == None:
        color = color_params('rp_approximated')
    else:
      results = self.mlmc.mcs [ self.mlmc.config.pick [self.mlmc.config.L] [0] ] .results [0]
      tend = numpy.array ( results.meta ['t'] ) [-1]
      model_class = getattr (rp, model)
      ts, rs, ps, drs, model_name = self.rp_integrated (r, p0_l, p0_g, rho_l, rho0_g, gamma, tend, mu, S, model_class() )
      label = model_name
      if mu:
        label += ' + dissipation'
      if color == None:
        color = color_params('rp_integrated')

    # report approximate collapse time
    print
    if count != 1:
      print ' :: Approximated (Rayleigh-Plesset) collapse time (for count = %d): %f' % (count, rp.approximate_collapse_time (r, p0_l, p0_g, rho_l) )
    else:
      print ' :: Approximated (Rayleigh-Plesset) collapse time: %f' % rp.approximate_collapse_time (r, p0_l, p0_g, rho_l)

    # report maximum pressure
    if not approximation:
      print
      if count != 1:
        print ' :: Approximated (%s) maximum pressure (for count = %d): %f' % ( model, count, numpy.max(ps) )
      else:
        print ' :: Approximated (%s) maximum pressure: %f' % ( model, numpy.max(ps) )
      print '  : -> Amplification factor \'p_max / p0_l\' is: %.1f' % (numpy.max(ps) / p0_l)
    
    # compute equivalent radius of simultaneously collapsing multiple bubbles
    if count != 1:
      label += ' (%d)' % count
      rs *= count ** (1.0 / 3.0)

    pylab.plot (ts, rs, color=color, linestyle=style(run), alpha=alpha(run), label=label)
    
    pylab.xlabel ('%s [%s]' % (name('t'),   unit('t')))
    pylab.ylabel ('%s [%s]' % (name('Req'), unit('Req')))
    
    if not frame:
      pylab.label (loc='best')
      self.draw (save, legend=True, loc='best', suffix='rp')

  # plot hinton diagram
  # source: http://matplotlib.org/examples/specialty_plots/hinton_demo.html
  def hinton (self, matrix, scale=0.95):
    
    ax = pylab.gca ()
    
    ax.patch.set_facecolor ('gray')
    ax.set_aspect ('equal', 'box')
    ax.xaxis.set_major_locator (pylab.NullLocator())
    ax.yaxis.set_major_locator (pylab.NullLocator())
    
    for (x, y), w in numpy.ndenumerate (matrix):
      color = 'white' if w > 0 else 'black'
      if x == y:
        color = 'gray'
      size = scale * numpy.sqrt (numpy.abs(w))
      #size = scale * numpy.abs(w)
      rect = pylab.Rectangle ([x - size / 2, y - size / 2], size, size, facecolor=color, edgecolor=color)
      ax.add_patch (rect)
    
    ax.autoscale_view ()
    ax.invert_yaxis ()

  '''
  # plot correlations between different qois
  def correlations (self, qois=None, hinton=True, infolines=False, save=None):
    
    if qois == None: qois = [ self.mlmc.config.solver.qoi ]
    
    level  = 'finest'
    type   = 0
    sample = 0
    
    results = self.mlmc.mcs [ self.mlmc.config.pick [level] [type] ] .results [sample]
    
    data = numpy.zeros ( (len (qois), len (results.meta ['t']) - 1) )
    for i, qoi in enumerate (qois):
      # exclude first data point, because some channels needs to
      data [i, :] = numpy.array ( results.data [qoi] ) [1:]
    
    # mask unavailable data
    data = numpy.ma.masked_array ( data, numpy.isnan (data) )
    
    # compute correlation matrix
    R = numpy.ma.corrcoef (data)
    
    pylab.figure ( figsize = (8, 8) )
    
    # plot Hinton diagram
    if hinton:
      plot_hinton (R)
      pylab.minorticks_off()
      pylab.gca().tick_params ( labelleft='on', labelright='off', labelbottom='off',labeltop='on' )
      pylab.gca().set_xticks ( numpy.arange ( len (qois) ) )
      pylab.gca().set_yticks ( numpy.arange ( len (qois) ) )
      pylab.gca().set_xticklabels ( [' ' + name (qoi, short=True) for qoi in qois], rotation='vertical')
      pylab.gca().set_yticklabels ( [name (qoi, short=True) + ' ' for qoi in qois] )

    # plot conventional correlation matrix
    else:
      pylab.pcolor (R)
      pylab.axis ('equal')
      pylab.xlim ( [0, len (qois)] )
      pylab.ylim ( [0, len (qois)] )
      pylab.xticks ( 0.5 + numpy.arange ( len (qois) ), qois )
      pylab.yticks ( 0.5 + numpy.arange ( len (qois) ), qois )
      pylab.colorbar ()
    
    if infolines:
      self.infolines ()

    pylab.subplots_adjust (bottom=0.05)
    pylab.subplots_adjust (right=0.95)
    pylab.subplots_adjust (left=0.20)
    pylab.subplots_adjust (top=0.80)
    
    self.draw (save, suffix='correlations')
  '''
