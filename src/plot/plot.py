
# # # # # # # # # # # # # # # # # # # # # # # # # #
# Plotting routines for stats generated by PyMLMC
# TODO: add paper, description and link
#
# Jonas Sukys
# CSE Lab, ETH Zurich, Switzerland
# sukys.jonas@gmail.com
# All rights reserved.
# # # # # # # # # # # # # # # # # # # # # # # # # #

# === global imports

import matplotlib

# for pylab.tight_layout()
#matplotlib.use('Agg')

import pylab
import numpy

# font configuration
matplotlib.rcParams ['font.size']             = 16
matplotlib.rcParams ['legend.fontsize']       = 14
matplotlib.rcParams ['lines.linewidth']       = 3
matplotlib.rcParams ['lines.markeredgewidth'] = 3
matplotlib.rcParams ['lines.markersize']      = 10

# additional colors
matplotlib.colors.ColorConverter.colors['a'] = (38/256.0,135/256.0,203/256.0)
matplotlib.colors.ColorConverter.colors['i'] = (251/256.0,124/256.0,42/256.0)
matplotlib.colors.ColorConverter.colors['j'] = (182/256.0,212/256.0,43/256.0)

# default color cycle
matplotlib.rcParams ['axes.color_cycle'] = ['a', 'i', 'j', 'c', 'y', 'm', 'g', 'r', 'b', 'burlywood', 'chartreuse', 'k']

# default styles
styles = [{}, {}]

styles [0] ['mean']             = 'a-'
styles [0] ['percentile']       = 'i-'
styles [0] ['std. deviation']   = 'j-'

styles [1] ['mean']             = 'm-'
styles [1] ['percentile']       = 'g-'
styles [1] ['std. deviation']   = 'r-'

styles [0] ['rp_integrated']    = 'k-'
styles [0] ['rp_approximated']  = 'k--'

styles [1] ['rp_integrated']    = 'j-'
styles [1] ['rp_approximated']  = 'j--'

styles [0] ['Req']              = 'a-'
styles [0] ['p_max']            = 'i-'
styles [0] ['ke']               = 'j-'
styles [0] ['mach_max']         = 'c-'

styles [1] ['Req']              = 'm-'
styles [1] ['p_max']            = 'g-'
styles [1] ['ke']               = 'r-'
styles [1] ['mach_max']         = 'b-'

styles [0] ['epsilon']          = 'a-'
styles [0] ['sigma']            = 'i-'
styles [0] ['samples']          = 'j-'
styles [0] ['errors']           = 'c-'
styles [0] ['error']            = 'k-'
styles [0] ['tol']              = 'm--'

styles [1] ['epsilon']          = 'm-'
styles [1] ['sigma']            = 'g-'
styles [1] ['samples']          = 'r-'
styles [1] ['errors']           = 'b-'
styles [1] ['error']            = 'k-'
styles [1] ['tol']              = 'm--'

units = {'t' : 'ms', 'Req' : r'$\mu$m', 'p_max' : 'bar', 'ke' : 'J', 'mach_max' : '-'}

# set levels extent
def levels_extent (levels):
  pylab.xlim ( [ -0.2, levels[-1]+0.2 ] )
  pylab.xticks (levels)

# generate figure name using the format 'figpath/pwd_suffix.extension'
def figname (suffix, extension='pdf'):
  import os
  figpath = 'fig'
  if not os.path.exists (figpath):
    os.mkdir (figpath)
  runpath, rundir = os.path.split (os.getcwd())
  return os.path.join (figpath, rundir + '_' + suffix + '.' + extension)

def figure (infolines=False, subplots=1):
  if infolines:
    pylab.figure(figsize=(subplots*8,6))
  else:
    pylab.figure(figsize=(subplots*8,5))

# adjust subplot margins
def adjust (infolines, subplots=1):
  
  pylab.subplots_adjust(top=0.92)
  pylab.subplots_adjust(right=0.95)
  
  if subplots == 1:
    pylab.subplots_adjust(left=0.14)
  else:
    pylab.subplots_adjust(left=0.08)

  if infolines:
    pylab.subplots_adjust(bottom=0.28)
  else:
    pylab.subplots_adjust(bottom=0.15)

# compute parameters needed for the generation of the TexTable
def getTexTableConfig (mlmc):
  
  # config
  
  keys     =  ['grid_size', 'cores', 'runtime', 'cluster']
  captions =  ['grid size', 'cores', 'runtime', 'cluster']
  
  # aggregation of information
  
  import time
  
  values               = {}
  values ['grid_size'] = 'x'.join ( [ str(parameter) for parameter in mlmc.config.discretizations [-1] .values() ] )
  values ['cores']     = mlmc.status ['parallelization']
  values ['cluster']   = mlmc.status ['cluster']
  
  if mlmc.finished:
    values ['runtime'] = time.strftime ( '%H:%M:%S', time.gmtime ( mlmc.mcs[-1].timer (mlmc.config.scheduler.batch) ) )
  else:
    values ['runtime'] = mlmc.status ['walltime']
  
  # number of levels

  if mlmc.L != 0:
    keys = ['L'] + keys
    captions = [r'$L$'] + captions
    values ['L'] = mlmc.L
  
  return [keys, captions, values]

# generate TeX code with the table including information about the simulation
def generateTexTable (mlmc, save):
  
  # get the config
  
  [keys, captions, opts] = getTexTableConfig (mlmc)
  
  # TeX code generation
  
  columns =  '|' + 'c|' * len(keys)
  
  text =  '\n'
  text += r'\begin{tabular}{%s}' % columns + '\n'
  
  text += r'\hline' + '\n'
  text += (r'%s & ' * len(captions))[0:-2] % tuple(captions) + r'\\' + '\n'
  text += r'\hline' + '\n'
  text += (r'%s & ' * len(keys))[0:-2] % tuple([opts[key] for key in keys]) + r'\\' + '\n'
  text += r'\hline' + '\n'
  
  text += r'\end{tabular}' + '\n'
  
  # saving
  f = open(save[0:-4] + '.tex', 'w')
  f.write(text)
  f.close()

# plot infolines with information about the simulation
def plot_infolines (mlmc):
  
  '''
  # text formatter
  def format_text (text, subplots):
    if not subplots and len(text) > 65:
      cut_pos = len(text)/2
      cut_pos = text.find(' ', cut_pos)
      text = text[:cut_pos] + '\n' + ' ' * 9 + text[cut_pos:]
    return text
  
  # CONF
  text  = prefix + format_text('CONF:' + ???, subplots) + '\n'
  
  # OPTS
  text += prefix + format_text('OPTS: ' + mlmc.options, subplots) + '\n'
  
  # INFO
  [keys, captions, values] = getTexTableConfig (mlmc)
  
  string_info  = ' CLUSTER: ' + config ['cluster']
  string_info += ', cores: ' + str(helpers.intf(int(config ['cores'])))
  string_info += ', runtime: ' + config ['runtime']

  text += prefix + format_text('INFO:' + string_info, subplots)
  
  # SAMPLES
  samples_available = self.samples and (self.i.L != 0 or self.i.ML != 1 or self.i.READ_NUMBER_OF_SAMPLES_FROM_FILE)
  if samples_available:
    text += '\n' + prefix + 'SAMPLES: ' + str(self.samples[::-1])[1:-1]
  
  # MESH_LEVEL and TYPE
  if level != None:
    text += ' (only the %d-sample MC estimate from MESH_LEVEL=%d and TYPE=%d is displayed)' % (self.samples[level+type], level, type)
  
  # default parallelization
  if self.default_parallelization:
    if samples_available:
      text += ' | '
    else:
      text += '\n'
    text += 'PARALLELIZATION:'
    for level in range(len(self.default_parallelization)):
      text += ' ' + str(self.default_parallelization[level][3]) + 'x(' + str(self.default_parallelization[level][0])
      if self.i.NY > 1: text += 'x' + str(self.default_parallelization[level][1])
      if self.i.NZ > 1: text += 'x' + str(self.default_parallelization[level][2])
      text += ')'
  
  return text
  '''
  return None

def saveall (mlmc, save):
  pylab.savefig    (save)
  pylab.savefig    (save[:-3] + 'eps')
  pylab.savefig    (save[:-3] + 'png')
  generateTexTable (mlmc, save)

def draw (mlmc, save, legend=False, loc='best'):
  if legend:
    pylab.legend (loc = loc)
  if save:
    saveall (mlmc, save)
  pylab.draw ()

# show plots
def show ():
  pylab.show()

# plot each stat
def plot_stats (qoi, stats, extent, run=1, legend=True, time='t'):
  
  percentiles = []
  
  run = (run-1) % len (styles)
  
  for name, stat in stats.iteritems():
    
    ts = numpy.array ( stat.meta [time] )
    vs = numpy.array ( stat.data [qoi]  )
    
    style = styles [run] [name] if name in styles [run] else ''
    if 'percentile' in name: style = styles [run] ['percentile']
    
    # stat-specific plotting: std. deviation
    if name == 'std. deviation' and 'mean' in stats:
      ms = numpy.array ( stats ['mean'] .data [qoi] )
      pylab.plot (ts, ms + vs, style, label='mean +/- std. dev.')
      pylab.plot (ts, ms - vs, style)
      color = colors [run] ['std. deviation'] [0]
      pylab.fill_between (ts, ms - vs, ms + vs, facecolor=color, alpha=0.2)
    
    # general plotting
    else:
      pylab.plot (ts, vs, style, label=name)
    
    # collect percentiles for later fill
    if 'percentile' in name:
      percentiles.append ([ts, vs])
  
  # plot percentiles
  lower = percentiles [0] [1]
  upper = percentiles [1] [1]
  color = styles [run] ['percentile'] [0]
  pylab.fill_between (ts, lower, upper, facecolor=color, alpha=0.2)
  
  if extent:
    pylab.ylim (*extent)
  
  if legend:
    pylab.xlabel (time)
    pylab.legend (loc='best')

# plot computed MC statistics
def plot_mc (mlmc, qoi=None, infolines=False, extent=None, run=1, frame=False, save=None):
  
  if not qoi: qoi = mlmc.config.solver.qoi
  
  levels = (len(mlmc.mcs) + 1) / 2
  
  if not frame:
    if infolines:
      pylab.figure (figsize=(levels*6, 4+5))
    else:
      pylab.figure (figsize=(levels*6, 2*4))
  
  for mc in mlmc.mcs:
    
    typestr = ['fine', 'coarse'] [mc.config.type]
    pylab.subplot ( 2, levels, mc.config.level + 1 + (mc.config.type == 1) * levels )
    pylab.title ( 'level %d %s' % (mc.config.level, typestr) )
    plot_stats ( qoi, mc.stats, extent, run, legend=False )
  
  handles, labels = pylab.gcf().gca().get_legend_handles_labels()
  #pylab.gcf().legend (handles, labels, loc=(0.05,0.25))
  pylab.subplot (2, levels, 1 + levels)
  pylab.legend (handles, labels, loc='center')
  pylab.axis('off')
  
  pylab.subplots_adjust(top=0.95)
  pylab.subplots_adjust(right=0.97)
  pylab.subplots_adjust(left=0.05)
  
  if infolines:
    plot_infolines (self)
    pylab.subplots_adjust(bottom=0.10)
  else:
    pylab.subplots_adjust(bottom=0.05)
  
  if infolines:
    plot_infolines (self)
  
  if not frame:
    draw (mlmc, save)

# plot computed MLMC statistics
def plot_mlmc (mlmc, qoi=None, infolines=False, extent=None, run=1, frame=False, save=None):
  
  if not qoi: qoi = mlmc.config.solver.qoi
  
  if not frame:
    figure (infolines, subplots=1)
  
  pylab.title ( 'estimated statistics for %s' % qoi )
  plot_stats (qoi, mlmc.stats, extent, run)
  
  if infolines:
    plot_infolines (self)

  adjust (infolines)

  if not frame:
    draw (mlmc, save)

# plot results of one sample of the specified level and type
def plot_sample (mlmc, level, type=0, sample=0, qoi=None, infolines=False, extent=None, run=1, label=None, frame=False, save=None):
  
  # some dynamic values
  if level  == 'finest':   level = mlmc.L
  if level  == 'coarsest': level = 0
  
  if not qoi: qoi = mlmc.config.solver.qoi
  
  results = mlmc.config.solver.load ( level, type, sample )
  
  ts = numpy.array ( results.meta ['t'] )
  vs = numpy.array ( results.data [qoi] )
  
  if not frame:
    figure (infolines, subplots=1)
  
  run = (run-1) % len (styles)
  if qoi in styles [run]:
    style = styles [run] [qoi]
  else:
    style = styles [run] ['mean']
  
  if not label:
    label = qoi
  
  pylab.plot  (ts, vs, style, label=label)
  
  if not mlmc.params.deterministic:
    pylab.title ( 'sample %d of %s at level %d of type %d' % (sample, qoi, level, type) )
  
  pylab.xlabel ('t [%s]' % units ['t'])
  pylab.ylabel ('%s [%s]' % (qoi, units [qoi]) )
  
  if extent:
    pylab.ylim(*extent)
  
  if infolines:
    plot_infolines (self)
  
  adjust (infolines)

  if not frame:
    draw (mlmc, save, legend=True, loc='best')

# plot the first sample of the finest level and type 0
# used mainly for deterministic runs
def plot (mlmc, qoi=None, infolines=False, extent=None, run=1, label=None, frame=False, save=None):
  level  = 'finest'
  type   = 0
  sample = 0
  plot_sample (mlmc, level, type, sample, qoi, infolines, extent, run, label, frame, save)

# plot results of all samples (ensemble) of the specified level and type 
def plot_ensemble (mlmc, level, type=0, qoi=None, infolines=False, extent=None, legend=4, save=None):
  
  # some dynamic values
  if level  == 'finest':   level  = mlmc.L
  if level  == 'coarsest': level  = 0
  
  if not qoi: qoi = mlmc.config.solver.qoi
  
  if not frame:
    figure (infolines, subplots=1)
  
  for sample in range(mlmc.config.samples.counts.computed[level]):
    
    results = mlmc.config.solver.load ( level, type, sample )
    
    ts = numpy.array ( results.meta ['t'] )
    vs = numpy.array ( results.data [qoi]  )
    
    pylab.plot  (ts, vs, label=str(sample), linewidth=1)
  
  pylab.title ( 'samples of %s at level %d of type %d' % (qoi, level, type) )
  
  if extent:
    pylab.ylim(*extent)

  if mlmc.config.samples.counts.computed[level] <= legend:
    pylab.legend (loc='best')
  
  if infolines:
    plot_infolines (self)
  
  adjust (infolines)
  
  draw (mlmc, save)

# plot indicators
def plot_indicators (mlmc, exact=None, infolines=False, run=1, frame=False, save=None):
  
  # === load all required data
  
  EPSILON       = mlmc.indicators.mean_diff
  SIGMA         = mlmc.indicators.variance_diff
  TOL           = mlmc.config.samples.tol
  NORMALIZATION = mlmc.errors.normalization
  levels        = mlmc.levels
  qoi           = mlmc.config.solver.qoi
  
  run = (run-1) % len (styles)
  
  # === compute error using the exact solution mean_exact
  
  if exact:
    
    # TODO: this needs to be reviewed
    error = numpy.abs ( exact - mlmc.stats [ qoi ] ) / NORMALIZATION
  
  # === plot
  
  if not frame:
    figure (infolines, subplots=2)
  
  # plot EPSILON
  
  pylab.subplot(121)
  pylab.semilogy (levels, [e / NORMALIZATION for e in EPSILON], style [run] ['epsilon'], marker='x', label='relative level means')
  if exact:
    pylab.axhline (y=error, xmin=levels[0], xmax=levels[-1], color = style [run] ['error'] [0], linestyle = style [run] ['error'] [1:], alpha=0.3, label='MLMC error (%1.1e) for K = 1' % error)
  pylab.axhline   (y=TOL,   xmin=levels[0], xmax=levels[-1], color = style [run] ['tol']   [0], linestyle = style [run] ['tol']   [1:], alpha=0.6, label='TOL = %1.1e' % TOL)
  pylab.title  ('Rel. level means for Q = %s' % qoi)
  pylab.ylabel (r'mean of relative $Q_\ell - Q_{\ell-1}$')
  pylab.xlabel ('mesh level')
  levels_extent (levels)
  pylab.legend (loc='upper right')
  
  # plot SIGMA
  
  pylab.subplot(122)
  pylab.semilogy (levels, numpy.sqrt(SIGMA) / NORMALIZATION, style [run] ['sigma'], marker='x', label='rel. level standard deviations')
  pylab.axhline (y=TOL, xmin=levels[0], xmax=levels[-1], color = style [run] ['tol'] [0], linestyle = style [run] ['tol'] [1:], alpha=0.6, label='TOL = %1.1e' % TOL)
  pylab.title  ('Rel. level standard deviations for Q = %s' % qoi)
  pylab.ylabel (r'standard deviation of rel. $Q_\ell - Q_{\ell-1}$')
  pylab.xlabel ('mesh level')
  levels_extent (levels)
  pylab.legend (loc='best')
  
  adjust (infolines, subplots=2)
  
  if infolines:
    show_info(self)
  
  if not frame:
    draw (mlmc, save)

# plot samples
def plot_samples (mlmc, infolines=False, warmup=True, optimal=True, run=1, frame=False, save=None):
  
  # === load all required data
  
  warmup_samples   = mlmc.config.samples.warmup
  samples          = mlmc.config.samples.counts.computed
  #counts_optimal   = mlmc.config.samples.counts_optimal
  #optimal_fraction = mlmc.config.samples.optimal_fraction
  TOL              = mlmc.config.samples.tol
  levels           = mlmc.levels
  
  run = (run-1) % len (styles)
  
  # === plot
  
  if not frame:
    figure (infolines, subplots=1)
  
  # plot number of samples
  
  #if warmup:
  #  pylab.semilogy (levels, warmup_samples, color='r', linestyle='--', marker='+', label='warmup')
  pylab.semilogy (levels, samples, style [run] ['samples'], marker='x', label='estimated for TOL=%1.1e' % TOL)
  #if optimal:
  #  pylab.semilogy (levels, counts_optimal, color='g', linestyle='--', marker='|', label='optimal (~%d%% less work)' % (100 * (1 - 1/optimal_fraction)))
  pylab.title  ('Estimated number of samples')
  pylab.ylabel ('number of samples')
  pylab.xlabel ('mesh level')
  levels_extent (levels)
  pylab.ylim   (ymin=0.7)
  #TODO: add light gray lines at y = 1, 2, 4 (OR: label data points)
  #OR: change to barplot, labeling data points
  if not frame:
    pylab.legend (loc='upper right')
  
  adjust (infolines)
  
  if infolines:
    show_info(self)

  if not frame:
    draw (mlmc, save)

# plot errors
def plot_errors (mlmc, infolines=False, run=1, frame=False, save=None):
  
  # === load all required data
  
  relative_error   = mlmc.errors.relative_error
  TOL              = mlmc.config.samples.tol
  levels           = mlmc.levels
  qoi              = mlmc.config.solver.qoi
  
  run = (run-1) % len (styles)
  
  # === plot
  
  if not frame:
    figure (infolines, subplots=1)
  
  # plot relative sampling error
  
  pylab.semilogy (levels, relative_error, style [run] ['errors'], marker='x', label='relative sampling errors')
  pylab.axhline  (y=TOL, xmin=levels[0], xmax=levels[-1], color = style [run] ['tol'] [0], linestyle = style [run] ['tol'] [1:], alpha=0.6, label='required TOL = %1.1e' % TOL )
  pylab.title  ('Relative sampling errors for Q = %s' % qoi)
  pylab.ylabel (r'relative error $\sqrt{\operatorname{Var} ( Q_\ell - Q_{\ell-1} ) / M_\ell}$')
  pylab.xlabel ('mesh level')
  levels_extent (levels)
  pylab.ylim   (ymax=1.5*TOL)
  pylab.legend (loc='lower left')
  
  adjust (infolines)
  
  if infolines:
    show_info(self)
  
  if not frame:
    draw (mlmc, save)

import rp

def rp_approximated (r, p0_l=100, p0_g=0.0234, rho_l=1000):
  tc = 0.914681 * r * numpy.sqrt ( rho_l / (p0_l - p0_g) )
  rp = lambda t : r * numpy.power (tc ** 2 - t ** 2, 2.0/5.0) / numpy.power (tc ** 2, 2.0/5.0)
  ts = numpy.linspace (0, tc, 10000)
  rs = rp(ts)
  return ts, rs

def rp_integrated (r, p0_l=100, p0_g=0.0234, rho_l=1000, rho0_g=1, gamma=1.4, tend=None, mu=0, S=0. model=rp.OptPL2()):
  dr0 = 0
  [ts, rs, ps, drs, name] = rp.integrate (r, p0_l, p0_g, rho_l, rho0_g, gamma, tend, dr0, mu, S, model)
  return numpy.array(ts), numpy.array(rs), numpy.array(ps), numpy.array(drs), name

# plot Rayleigh Plesset
def plot_rp (mlmc, r, p0_l=100, p0_g=0.0234, rho_l=1000, rho0_g=1, gamma=1.4, mu=0, S=0, count=1, style=None, approximation=False, model='OptPL2', run=1, frame=False, save=None):
  
  run = (run-1) % len (styles)
  
  if r == None:
    r = numpy.array ( mlmc.config.solver.load ( mlmc.L, 0, 0 ) .data ['Req'] ) [0]
    if count != 1:
      r /= count ** (1.0/3.0)
  
  if not frame:
    figure (infolines=False, subplots=1)
  
  if approximation:
    ts, rs = rp_approximated (r, p0_l, p0_g, rho_l)
    label = 'Rayleigh-Plesset (approx.)'
    if style == None:
      style = styles [run] ['rp_approximated']
  else:
    results = mlmc.config.solver.load ( mlmc.L, 0, 0 )
    ts = numpy.array ( results.meta ['t'] )
    tend = ts [-1]
    model_class = getattr (numpy, model)
    ts, rs, ps, drs, name = rp_integrated (r, p0_l, p0_g, rho_l, rho0_g, gamma, tend, mu, S, model_class() )
    label = name
    if mu:
      label += ' + dissipation'
    if style == None:
      style = styles [run] ['rp_integrated']

  # report approximate collapse time
  print
  print ' :: Approximated (Rayleigh-Plesset) collapse time: %f' % rp.approximate_collapse_time (r, p0_l, p0_g, rho_l)
  
  # compute equivalent radius of simultaneously collapsing multiple bubbles
  if count != 1:
    label += ' (%d)' % count
    rs *= count ** (1.0 / 3.0)

  pylab.plot (ts, rs, style, alpha=0.5, label=label)
  
  if not frame:
    pylab.label (loc='best')
    draw (mlmc, save, legend=True, loc='best')